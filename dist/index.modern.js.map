{"version":3,"file":"index.modern.js","sources":["../src/core/convertor/default-externals.ts","../src/core/context/ObjectPool.ts","../src/core/context/Context.ts","../src/core/convertor/Convertor.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/core/execution/ExecutionStep.ts","../src/core/scripts/Script.ts","../src/core/convertor/utils/script-utils.ts","../src/core/convertor/actions/convert-action.ts","../src/core/convertor/actions/parameter-utils.ts","../src/core/resolutions/formula/Formula.ts","../src/core/resolutions/formula/formula-utils.ts","../src/core/resolutions/formula/formula-evaluator.ts","../src/core/resolutions/calculateArray.ts","../src/core/resolutions/calculateMap.ts","../src/core/resolutions/calculateObjectResolution.ts","../src/core/resolutions/calculate.ts","../src/core/resolutions/calculateNumber.ts","../src/core/resolutions/calculateString.ts","../src/core/resolutions/calculateBoolean.ts","../src/core/types/ValueOf.ts","../src/core/resolutions/calculateTypeArray.ts","../src/core/convertor/actions/refresh-convertor.ts","../src/core/convertor/actions/actions-convertor.ts","../src/core/convertor/actions/callback-convertor.ts","../src/core/convertor/actions/condition-convertor.ts","../src/core/convertor/actions/convert-external-call.ts","../src/core/convertor/actions/convert-pause.ts","../src/core/convertor/actions/convert-set.ts","../src/core/convertor/actions/hooks-convertor.ts","../src/core/convertor/actions/log-convertor.ts","../src/core/convertor/actions/loop-convertor.ts","../src/core/convertor/actions/parameters-convertor.ts","../src/core/convertor/actions/script-convertor.ts","../src/core/convertor/default-convertors.ts","../src/core/processor/ScriptProcessor.ts"],"sourcesContent":["export const DEFAULT_EXTERNALS = {\n    log: console.log,\n    setTimeout,\n    clearTimeout,\n    fetch: global.fetch,\n};\n","export class ObjectPool<T> {\n    private factory: () => T;\n    private cleanup: (value: T) => void;\n    private pool: T[] = [];\n    constructor(factory: () => T, cleanup: (value: T) => void) {\n        this.factory = factory;\n        this.cleanup = cleanup;\n    }\n\n    generate(): T {\n        return this.pool.pop() ?? this.factory();\n    }\n\n    recycle(value: T) {\n        this.cleanup(value);\n        this.pool.push(value);\n    }\n}","import { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { ExecutionParameters, ExecutionStep } from \"../execution/ExecutionStep\";\nimport { ObjectPool } from \"./ObjectPool\";\n\nexport interface ExecutionWithParams {\n    steps: ExecutionStep[];\n    parameters: ExecutionParameters;\n}\n\nexport class Context<E = {}> {\n    parameters: ExecutionParameters[];\n    objectPool: ObjectPool<ExecutionParameters>;\n    external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    locked: Set<string>;\n    private postActionListener: Set<ExecutionWithParams>;\n    private cleanupActions:(() => void)[];\n\n    constructor({\n        parameters = [],\n        cleanupActions = [],\n        objectPool = new ObjectPool<ExecutionParameters>(() => ({}), value => {\n            for (let k in value) {\n                delete value[k];\n            }\n        }),\n        postActionListener = new Set(),\n        external = {}\n    }: {\n        parameters?: ExecutionParameters[];\n        cleanupActions?:(() => void)[];\n        objectPool?: ObjectPool<ExecutionParameters>;\n        postActionListener?: Set<ExecutionWithParams>;\n        external?: E | {}\n    } = {}) {\n        this.parameters = parameters;\n        this.cleanupActions = cleanupActions;\n        this.objectPool = objectPool;\n        this.postActionListener = postActionListener;\n        this.external = {...DEFAULT_EXTERNALS, ...external};\n        this.locked = new Set();\n    }\n\n    addCleanup(cleanup: () => void) {\n        this.cleanupActions.push(cleanup);        \n    }\n\n    addPostAction(postAction: ExecutionWithParams) {\n        if (!this.postActionListener.has(postAction)) {\n            postAction.parameters.postAction = postAction;\n            this.postActionListener.add(postAction);\n        }\n    }\n\n    deletePostAction(postAction: ExecutionWithParams): void {\n        this.postActionListener.delete(postAction);\n    }\n\n    executePostActions(parameters: ExecutionParameters): void {\n        this.postActionListener.forEach(listener => {\n            for (let i in parameters) {\n                listener.parameters[i] = parameters[i];\n            }\n            listener.steps.forEach(step => step(listener.parameters, this));\n        });\n    }\n\n    cleanup() {\n        this.cleanupActions.forEach(action => action());\n        this.cleanupActions.length = 0;\n    }\n\n    clear() {\n        this.cleanup();\n        this.postActionListener.clear();\n    }\n}\n\nexport function createContext<E>({\n        parameters = [],\n        cleanupActions = [],\n        objectPool = new ObjectPool<ExecutionParameters>(() => ({}), value => {\n            for (let k in value) {\n                delete value[k];\n            }\n        }),\n        postActionListener = new Set(),\n        external = {},\n}: {\n    parameters?: ExecutionParameters[];\n    cleanupActions?:(() => void)[];\n    objectPool?: ObjectPool<ExecutionParameters>;\n    postActionListener?: Set<ExecutionWithParams>;\n    external?: E | {};\n} = {}): Context<E|{}> {\n    return new Context({parameters, cleanupActions, objectPool, postActionListener, external});\n}\n","import { Context } from \"../context/Context\";\nimport { ExecutionParameters, ExecutionStep } from \"../execution/ExecutionStep\";\nimport { RefreshBehavior } from \"../processor/ScriptProcessor\";\nimport { ScriptFilter } from \"../scripts/Script\";\n\nexport type ActionConvertorList = Convertor<any>[];\n\nexport interface ConvertorSet {\n    actionsConvertor: ActionConvertorList,\n}\n\nexport type GetSteps = (filter: ScriptFilter) => StepScript;\n\nexport enum ConvertBehavior {\n    NONE,\n    SKIP_REMAINING_CONVERTORS,\n    SKIP_REMAINING_ACTIONS,\n}\n\nexport interface Utils<T> {\n    refreshSteps(steps: StepScript, loopBehavior?: RefreshBehavior, processId?: string): { cleanup: () => void; processId: string };\n    stopRefresh(processId?: string): void;\n    getSteps: GetSteps;\n    getRemainingActions: () => T[];\n    executeCallback?: Record<string, (context: Context, additionalParameters: ExecutionParameters) => void>;\n}\n\nexport class StepScript {\n    private steps: ExecutionStep[] = [];\n\n    constructor(steps?: ExecutionStep[]) {\n        steps?.forEach(step => this.add(step));\n    }\n\n    add(step: ExecutionStep) {\n        this.steps.push(step);\n    }\n\n    getSteps() {\n        return this.steps;\n    }\n}\n\nexport type Convertor<T> = (action: T, results: StepScript, utils: Utils<T>, external: Record<string, any>, convertorSet: ConvertorSet) => Promise<ConvertBehavior | void>;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Context, createContext } from \"../context/Context\";\nimport { StepScript } from \"../convertor/Convertor\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\n\nexport type ExecutionParameters = Record<string, SupportedTypes|any>;\nexport type ExecutionStep = (parameters: ExecutionParameters, context: Context) => void;\n\nexport function execute(steps: StepScript, parameters: ExecutionParameters = {}, context: Context = createContext()) {\n    if (!steps.getSteps().length) {\n        return;\n    }\n    if (!context.parameters) {\n        context.parameters = [];\n    }\n\n    const params = context.parameters;\n    const changedParameters = params[params.length-1] !== parameters;\n    if (changedParameters) {\n        params.push(parameters);\n    }\n    for (let step of steps.getSteps()) {\n        step(parameters, context);\n    }\n    context.executePostActions(parameters);\n\n    if (changedParameters) {\n        params.pop();\n    }\n}\n","import { ActionList } from \"../actions/ActionsAction\";\n\nexport type Tag = string|[string, string|number|boolean];\n\nexport interface Script<T> {\n    name?: string;\n    actions?: ActionList<T>;\n    scripts?: Script<T>[];\n    tags?: Tag[];\n}\n\nexport interface ScriptFilter {\n    name?: string | string[];\n    tags?: Tag[];\n}\n\nfunction filterMatchesTags(filter: ScriptFilter, tags?: Tag[]) {\n    return filter.tags?.every(tag => {\n        if (typeof(tag) === \"string\") {\n            return tags?.some((t) => t === tag || (Array.isArray(t) && t[0] === tag));\n        } else {\n            return tags?.some((t) => Array.isArray(t) && t[0] === tag[0] && t[1] === tag[1]);\n        }\n    });\n}\n\nexport function filterScripts<T>(scripts: Script<T>[], filter: ScriptFilter): Script<T>[] {\n    return filterScriptsHelper(scripts, filter);\n}\n\nexport function filterScriptsHelper<T>(scripts: Script<T>[], filter: ScriptFilter): Script<T>[] {\n    const namesToFilter = !filter.name ? undefined : Array.isArray(filter.name) ? filter.name : [filter.name];\n    return scripts.filter(({name, tags}) => {\n        if (namesToFilter?.length && namesToFilter.indexOf(name ?? \"\") < 0) {\n            return false;\n        }    \n        if (filter.tags && !filterMatchesTags(filter, tags)) {\n            return false;\n        }\n        return true;\n    });\n}\n","import { ScriptProcessorHelper } from \"../../processor/ScriptProcessor\";\nimport { Script, ScriptFilter, filterScripts } from \"../../scripts/Script\";\nimport { ConvertBehavior, ConvertorSet, StepScript } from \"../Convertor\";\nimport { convertAction } from \"../actions/convert-action\";\n\nexport function spreadScripts<T>(scripts: Script<T>[] = [], results: Script<T>[] = []): Script<T>[] {\n    scripts.forEach(script => {\n        spreadScripts(script.scripts, results);\n        results.push(script);\n    });\n    return results;\n}\n\nexport async function convertScripts<T>(\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        convertorSet: ConvertorSet,\n        processorHelper: ScriptProcessorHelper): Promise<Map<Script<T>, StepScript>> {\n    return convertScriptsHelper<T>(spreadScripts(scripts), external, convertorSet, processorHelper);\n}\n\nasync function convertScriptsHelper<T>(\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        convertorSet: ConvertorSet,\n        processorHelper: ScriptProcessorHelper): Promise<Map<Script<T>, StepScript>> {\n    const scriptMap: Map<Script<T>, StepScript> = new Map();\n    scripts.forEach(script => scriptMap.set(script, new StepScript()));\n    const getSteps = (filter: ScriptFilter) => {\n        const filteredScripts = filterScripts(scripts, filter);\n        const steps: StepScript = new StepScript();\n        filteredScripts.forEach(script => {\n            const stepScript = scriptMap.get(script);\n            stepScript?.getSteps().forEach(step => steps.add(step));\n        });\n        return steps;\n    };\n    for (let script of scripts) {\n        const scriptSteps = scriptMap.get(script) ?? new StepScript();\n        const { actions = [] } = script;\n        for (let i = 0; i < actions.length; i++) {\n            const getRemainingActions = () => actions.slice(i + 1);\n            const convertBehavior = await convertAction(actions[i], scriptSteps, {\n                getSteps, getRemainingActions, refreshSteps: processorHelper.refreshSteps, stopRefresh: processorHelper.stopRefresh,\n            }, external, convertorSet);\n            if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n                break;\n            }\n        }\n    }\n    return scriptMap;\n}\n","import { Context, createContext } from \"../../context/Context\";\nimport { ExecutionParameters, execute } from \"../../execution/ExecutionStep\";\nimport { ScriptProcessorHelper } from \"../../processor/ScriptProcessor\";\nimport { Script } from \"../../scripts/Script\";\nimport { convertScripts } from \"../utils/script-utils\";\nimport { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"./../Convertor\";\n\nexport async function convertAction<T>(\n        action: T,\n        stepResults: StepScript,\n        utils: Utils<T>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    for (let convertor of convertorSet.actionsConvertor) {\n        const convertBehavior = await convertor(action, stepResults, utils, external, convertorSet);\n        if (convertBehavior === ConvertBehavior.SKIP_REMAINING_CONVERTORS) {\n            return;\n        } else if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n            return convertBehavior;\n        }\n    }\n    return;    \n}\n\nexport async function executeScript<T>(\n        scriptName: string,\n        parameters: ExecutionParameters = {},\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        convertorSet: ConvertorSet,\n        processorHelper: ScriptProcessorHelper): Promise<() => void> {\n    const context: Context = createContext();\n    const scriptMap = await convertScripts(scripts, external, convertorSet, processorHelper);\n    const script = scripts.find(({name}) => name === scriptName);\n    const steps = (script ? scriptMap.get(script) : null) ?? new StepScript();\n    execute(steps, parameters, context);\n    return () => context.clear();\n}\n\nexport async function executeAction<T>(\n        action: T,\n        parameters: ExecutionParameters,\n        context: Context,\n        utils: Utils<T>,\n        convertorSet: ConvertorSet): Promise<void> {\n    const results: StepScript = new StepScript();\n    if (ConvertBehavior.SKIP_REMAINING_ACTIONS !== await convertAction(action, results, utils, context.external, convertorSet)) {\n        execute(results, parameters, context);\n    }\n}","import { Context } from \"../../context/Context\";\nimport { ExecutionParameters } from \"../../execution/ExecutionStep\";\n\nexport function newParams(parameters: ExecutionParameters | undefined, context: Context): ExecutionParameters {\n    const params = context.objectPool.generate();\n    for (let k in parameters) {\n        params[k] = parameters[k];\n    }    \n    return params;\n}\n\nexport function recycleParams(params: ExecutionParameters, context: Context): void {\n    context.objectPool.recycle(params);\n}\n\n","export const FORMULA_SEPARATORS = [\"~\", \"{\", \"}\"];   //  formula separator\n\nexport type Formula = string\n","import { Resolution } from \"../Resolution\";\nimport { FORMULA_SEPARATORS, Formula } from \"./Formula\";\n\nexport function hasFormula(resolution: Resolution): boolean {\n    if (isFormula(resolution)) {\n        return true;\n    }\n    if (Array.isArray(resolution)) {\n        return resolution.some(item => hasFormula(item));\n    }\n    if (resolution && typeof (resolution) === \"object\") {\n        return hasFormula(Object.values(resolution)) || hasFormula(Object.keys(resolution));\n    }\n    return false;\n}\n\nexport function isFormula(value: Formula | any) {\n    if (!value) {\n        return false;\n    }\n    if (typeof(value) !== \"string\" && typeof(value) !== \"object\") {\n        return false;\n    }\n    const formula = typeof(value) === \"string\" ? value : value.formula;\n    const [startCharacter, prefix, suffix] = FORMULA_SEPARATORS.map(char => formula?.indexOf(char));\n    return startCharacter === 0 && prefix > startCharacter && suffix > prefix;\n}\n\ninterface FormulaChunk {\n    formula: Formula;\n    textSuffix: string;\n}\n\nexport function getInnerFormulas(formula: Formula): FormulaChunk[] {\n    const [startCharacter, prefix, suffix] = FORMULA_SEPARATORS;\n\n    //  parse formulas out. Formulas have format like this: ~{formula}text{formula}.\n    return formula.substring(startCharacter.length).split(prefix).map((chunk, index) => {\n        if (index === 0) {\n            return { textSuffix: chunk, formula: \"\" };\n        }\n        const [formula, textSuffix] = chunk.split(suffix);\n        return { formula, textSuffix };\n    }).filter(({ textSuffix, formula}) => textSuffix.length || formula.length);\n}\n\nconst IDENTIFIER_REGEX = /^([^\\x00-\\x7F]|[A-Za-z_])([^\\x00-\\x7F]|\\w)+$/;\n\nexport function isSimpleInnerFormula(innerFormula: string) {\n    return IDENTIFIER_REGEX.test(innerFormula);\n}\n\n","import * as math from \"mathjs\";\nimport { FORMULA_SEPARATORS, Formula } from \"./Formula\";\nimport { getInnerFormulas, isFormula, isSimpleInnerFormula } from \"./formula-utils\";\nimport { ExecutionParameters } from \"../../execution/ExecutionStep\";\n\nexport function calculateEvaluator<T>(evaluator: math.EvalFunction, parameters: ExecutionParameters = {}, formula: Formula, defaultValue: T): T {\n    const scope = parameters;\n    try {\n        return evaluator.evaluate(scope ?? {}) ?? defaultValue;\n    } catch (e) {\n        console.error(\"Error: \" + e + \" on formula: \" + formula + \", scope: \", scope);\n        debugger;\n    }\n    return defaultValue;\n}\n\nfunction getEvaluator(formula: string): math.EvalFunction {\n    if (!formula.length) {\n        return {\n            evaluate: () => \"\",\n        };\n    }\n    const mathEvaluator = math.parse(formula).compile();\n    if (isSimpleInnerFormula(formula)) {\n        return {\n            evaluate(scope?: any) {\n                return scope[formula] ?? mathEvaluator.evaluate(scope);\n            },\n        };\n    }\n    return mathEvaluator;    \n}\n\nexport function getFormulaEvaluator(value: Formula): math.EvalFunction {\n    if (!isFormula(value)) {\n        throw new Error(`Formula: ${value} must match the format: \"${FORMULA_SEPARATORS[0]}formula${FORMULA_SEPARATORS[1]}\".`);\n    }\n    const values = getInnerFormulas(value);\n    if (values.length === 1 && !values[0].textSuffix.length) {\n        return getEvaluator(values[0].formula);\n    } else {\n        const evaluators = values.map(({ formula, textSuffix }) => {\n            return { mathEvaluator: getEvaluator(formula), textSuffix};\n        });\n\n        return {\n            evaluate(scope?: any) {\n                return evaluators.map(({ mathEvaluator, textSuffix }) => {\n                    return mathEvaluator.evaluate(scope) + textSuffix;\n                }).join(\"\");\n            },\n        };\n    }\n}\n\n","import { ValueOf } from \"../types/ValueOf\";\nimport { ArrayResolution } from \"./ArrayResolution\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { Formula } from \"./formula/Formula\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { hasFormula, isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateArray(value: ArrayResolution): ValueOf<SupportedTypes[] | undefined> | undefined {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        if (!Array.isArray(value)) {\n            throw new Error(\"value is not an array\");\n        }\n        const array = value as SupportedTypes[];\n        return { valueOf: () => array };\n    }\n    if (!value) {\n        return undefined;\n    }\n    if (isFormula(value)) {\n        const formula = value as Formula;\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(parameters: ExecutionParameters): SupportedTypes[] | undefined {\n                return calculateEvaluator<SupportedTypes[] | undefined>(evaluator, parameters, formula, undefined);\n            }\n        };\n    }\n    const array = value as Resolution[]\n\n    const evaluator = array.map(resolution => calculateResolution(resolution));\n\n    return {\n        valueOf(parameters: ExecutionParameters): SupportedTypes[] {\n            return evaluator.map(evalItem => evalItem?.valueOf(parameters));\n        }\n    };\n}","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { Formula } from \"./formula/Formula\";\nimport { MapResolution } from \"./MapResolution\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { hasFormula, isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateMap(value: MapResolution): ValueOf<{ [key:string]:SupportedTypes } | undefined> {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        const map = value as {[key: string]:SupportedTypes}\n        return { valueOf: () => map };\n    }\n    if (isFormula(value)) {\n        const formula = value as Formula;\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(parameters: ExecutionParameters): { [key:string]:SupportedTypes } | undefined {\n                return calculateEvaluator<{ [key:string]:SupportedTypes } | undefined>(evaluator, parameters, formula, undefined);\n            }\n        };\n    }\n    \n    const map = value as {[key: string]:Resolution}\n    const evaluatorEntries = Object.entries(map).map(([key, resolution]) => [key, calculateResolution(resolution)]);\n\n    return {\n        valueOf(parameters: ExecutionParameters): { [key:string]:SupportedTypes } | undefined {\n            return Object.fromEntries(evaluatorEntries.map(([key, evalItem]) => [key, evalItem?.valueOf(parameters)]));\n        }\n    };\n}","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateResolution } from \"./calculate\";\nimport { ObjectResolution } from \"./ObjectResolution\";\n\nexport function calculateObject<T extends any = object, U = object | undefined>(value: ObjectResolution, defaultValue?: U): ValueOf<T | U> {\n    const subject = calculateResolution(value.subject);\n    const access = (value.access ?? []).map(key => calculateResolution(key));\n    const formula = value.formula ? calculateResolution(value.formula) : undefined;\n\n    return {\n        valueOf(parameters) {\n            let node = subject?.valueOf(parameters);\n            const keys = access.map(key => key?.valueOf(parameters));\n            for (let key of keys) {\n                if (Array.isArray(node)) {\n                    if (typeof key === \"number\") {\n                        node = node?.[key];\n                    } else {\n                        node = undefined;\n                        break;\n                    }\n                } else if (typeof key === \"string\" && typeof(node) === \"object\") {\n                    node = (node as Record<string, any>)?.[key];\n                } else {\n                    node = undefined;\n                    break;\n                }\n            }\n            if (formula && parameters) {\n                parameters.value = node;\n                node = formula.valueOf(parameters);\n            }\n            return (node ?? defaultValue) as (T | U);\n        },\n    };\n}","import { ValueOf } from \"../types/ValueOf\";\nimport { Resolution } from \"./Resolution\";\nimport { calculateArray } from \"./calculateArray\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { calculateMap } from \"./calculateMap\";\nimport { isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { calculateObject } from \"./calculateObjectResolution\";\nimport { ObjectResolution } from \"./ObjectResolution\";\n\nexport function calculateResolution(value: Resolution): ValueOf<SupportedTypes> | undefined | null {\n    if (!value) {\n        return {\n            valueOf() {\n                return value;\n            }\n        };\n    }\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n    if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return value;\n    }\n    if (typeof(value) === \"string\" && !isFormula(value)) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return calculateArray(value);\n    }\n    if (typeof(value) === \"object\") {\n        if (value.subject) {\n            return calculateObject(value as ObjectResolution);\n        }\n        return calculateMap(value);\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters = {}): SupportedTypes {\n            return calculateEvaluator<SupportedTypes>(evaluator, parameters, value, undefined);\n        }\n    };\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { ObjectResolution } from \"./ObjectResolution\";\nimport { calculateObject } from \"./calculateObjectResolution\";\n\n\nexport function calculateNumber<T extends number = number>(value: NumberResolution<T> | ObjectResolution, defaultValue:T|0 = 0): ValueOf<T|0>|number {\n    if (typeof(value) === \"number\") {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    if (typeof(value) === \"object\") {\n        if (value.subject) {\n            return calculateObject<T, T|0>(value as ObjectResolution);\n        }\n        throw new Error(\"Invalid expression. You need a subject\");\n    }\n\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters?: ExecutionParameters): T|0 {\n            return calculateEvaluator<T|0>(evaluator, parameters, value, defaultValue);\n        }\n    };\n}\n","import { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ObjectResolution } from \"./ObjectResolution\";\nimport { StringResolution } from \"./StringResolution\";\nimport { calculateObject } from \"./calculateObjectResolution\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { isFormula } from \"./formula/formula-utils\";\n\nexport function calculateString<T extends string = string>(value: StringResolution<T> | ObjectResolution, defaultValue: T|\"\" = \"\"): ValueOf<T|\"\">|string {\n    if (typeof(value) === \"string\" && !isFormula(value)) {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    if (typeof(value) === \"object\") {\n        if (value.subject) {\n            return calculateObject<T, T | \"\">(value as ObjectResolution, defaultValue);\n        }\n        throw new Error(\"Invalid expression. You need a subject\");\n    }\n\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters): T|\"\" {\n            return calculateEvaluator<T|\"\">(evaluator, parameters, value, defaultValue);\n        }\n    };\n\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\nimport { BooleanResolution } from \"./BooleanResolution\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { ObjectResolution } from \"./ObjectResolution\";\nimport { calculateObject } from \"./calculateObjectResolution\";\n\nexport function calculateBoolean(value: BooleanResolution | NumberResolution | ObjectResolution, defaultValue = false): ValueOf<boolean> {\n    if (typeof(value) === \"boolean\" || typeof(value) === \"number\") {\n        return !!value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    if (typeof(value) === \"object\") {\n        if (value.subject) {\n            return calculateObject(value as ObjectResolution);\n        }\n        throw new Error(\"Invalid expression. You need a subject\");\n    }\n\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters): boolean {\n            return !!calculateEvaluator<boolean | number>(evaluator, parameters, value, defaultValue);\n        }\n    };\n}\n","import { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport type ValueOf<T> = {\n    valueOf(parameters?: ExecutionParameters): T;\n}\n\nexport function convertValueOf<T, U>(val: ValueOf<T>, convertor: (value: T) => U): ValueOf<U> {\n    return {\n        valueOf(parameters: ExecutionParameters) {\n            return convertor(val.valueOf(parameters));\n        }\n    };\n}","import { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { GlType } from \"../types/GlType\";\nimport { TypedArray } from \"../types/TypedArray\";\nimport { convertValueOf, ValueOf } from \"../types/ValueOf\";\nimport { calculateNumber } from \"./calculateNumber\";\nimport { calculateString } from \"./calculateString\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { StringResolution } from \"./StringResolution\";\nimport { TypedArrayResolution } from \"./TypedArrayResolution\";\n\nexport interface TypedArrayConstructor {\n    new (size: number): TypedArray;\n    BYTES_PER_ELEMENT: number;\n}\n\nexport function getGlType(type: StringResolution<GlType>): ValueOf<GLenum> {\n  const glType = calculateString<GlType>(type);\n  if (type && typeof(type) !== \"string\") {\n    return {\n      valueOf(parameters: ExecutionParameters) {\n        return getGlType(glType.valueOf(parameters)).valueOf(parameters);\n      }\n    };\n  }\n  switch(type) {\n    case \"BYTE\":\n      return WebGL2RenderingContext.BYTE;\n    case \"FLOAT\":\n      return WebGL2RenderingContext.FLOAT;\n    case \"SHORT\":\n      return WebGL2RenderingContext.SHORT;\n    case \"UNSIGNED_BYTE\":\n      return WebGL2RenderingContext.UNSIGNED_BYTE;\n    case \"UNSIGNED_SHORT\":\n      return WebGL2RenderingContext.UNSIGNED_SHORT;\n    case \"INT\":\n      return WebGL2RenderingContext.INT;\n    case \"UNSIGNED_INT\":\n      return WebGL2RenderingContext.UNSIGNED_INT;\n  }\n  return WebGL2RenderingContext.FLOAT;  \n}\n\nexport function getTypedArray(type: GlType | string | undefined): TypedArrayConstructor {\n  switch(type) {\n      case \"BYTE\":\n        return Int8Array;\n      case \"FLOAT\":\n        return Float32Array;\n      case \"SHORT\":\n        return Int16Array;\n      case \"UNSIGNED_BYTE\":\n        return Uint8Array;\n      case \"UNSIGNED_SHORT\":\n        return Uint16Array;\n      case \"INT\":\n        return Int32Array;\n      case \"UNSIGNED_INT\":\n        return Uint32Array;\n  }\n  return Float32Array;\n}\n\nexport function getByteSize(type?: StringResolution<GlType>): ValueOf<number> {\n  const typeArray = calculateTypeArrayConstructor(type);\n  return {\n    valueOf(parameters: ExecutionParameters) {\n      return typeArray.valueOf(parameters).BYTES_PER_ELEMENT;\n    }\n  };\n}\n\nexport function getTypeArrayContructor(glType?: GlType | string): ValueOf<TypedArrayConstructor> {\n  return {\n    valueOf() {\n        return getTypedArray(glType);\n    }\n  };\n}\n\nexport function calculateTypeArrayConstructor(glType: StringResolution<GlType>): ValueOf<TypedArrayConstructor> {\n  const glTypeValueOf = calculateString<GlType>(glType);\n  return convertValueOf(glTypeValueOf, getTypedArray);\n}\n\nexport function calculateTypedArray(value: TypedArrayResolution, typedArrayContructor: ValueOf<TypedArrayConstructor> = getTypeArrayContructor(\"FLOAT\")): ValueOf<TypedArray | undefined> {\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n\n    let ArrayConstructor: TypedArrayConstructor | undefined = undefined;\n    if (Array.isArray(value)) {\n        const compiledArray = value.map(value => calculateNumber(value, 0));\n        return {\n            valueOf(parameters: ExecutionParameters): TypedArray {\n                if (!ArrayConstructor) {\n                    ArrayConstructor = typedArrayContructor.valueOf(parameters);\n                }\n                const array = new ArrayConstructor(value.length);\n                for (let i = 0; i < compiledArray.length; i++) {\n                    array[i] = compiledArray[i].valueOf(parameters);\n                }\n                return array;\n            }\n        };    \n    }\n    const formula = value;\n    const evaluator = getFormulaEvaluator(formula);\n    let bufferArray: TypedArray;\n    return {\n        valueOf(parameters: ExecutionParameters): TypedArray | undefined {\n            const value = calculateEvaluator<TypedArray | number[] | undefined>(evaluator, parameters, formula, undefined);\n            if (!value) {\n                return undefined;\n            }\n            if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n                || value instanceof Int16Array || value instanceof Uint16Array\n                || value instanceof Int32Array || value instanceof Uint32Array) {\n                return value;\n            }\n            if (!ArrayConstructor) {\n                ArrayConstructor = typedArrayContructor.valueOf(parameters);\n            }\n            if (Array.isArray(value)) {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value.length);\n                }\n                bufferArray.set(value);\n                return bufferArray;\n            }\n        \n            if (typeof(value) === \"number\") {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value / ArrayConstructor.BYTES_PER_ELEMENT);\n                }\n                return bufferArray;\n            }\n\n            throw new Error(`Formula ${formula} doesnt't evaluate to a TypedArray.`);\n        }\n    };\n}","import { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { calculateNumber } from \"../../resolutions/calculateNumber\";\nimport { convertAction } from \"./convert-action\";\nimport { RefreshAction } from \"../../actions/RefreshAction\";\nimport { calculateBoolean } from \"../../resolutions/calculateBoolean\";\nimport { calculateString } from \"../../resolutions/calculateString\";\n\nexport const DEFAULT_REFRESH_FRAME_RATE = 1;\n\nexport async function convertRefreshProperty<T>(\n        action: T & RefreshAction,\n        stepResults: StepScript,\n        utils: Utils<T & RefreshAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.refresh) {\n        return;\n    }\n    const { refresh, ...subAction } = action;\n    const subStepResults: StepScript = new StepScript();\n    const processIdValue = calculateString(refresh.processId, \"\");\n    const stop = calculateBoolean(refresh.stop);\n    const cleanupAfterRefresh = calculateBoolean(refresh.cleanupAfterRefresh);\n    const frameRate = calculateNumber(refresh.frameRate, DEFAULT_REFRESH_FRAME_RATE);\n    await convertAction<RefreshAction>(subAction, subStepResults, utils, external, convertorSet);\n\n    stepResults.add((parameters, context) => {\n        if (stop.valueOf(parameters)) {\n            utils.stopRefresh(processIdValue.valueOf(parameters));\n        } else {\n            const {cleanup, processId} = utils.refreshSteps(subStepResults, {\n                cleanupAfterRefresh: cleanupAfterRefresh.valueOf(parameters),\n                frameRate: frameRate.valueOf(parameters),\n                parameters,\n            }, processIdValue.valueOf(parameters));\n            parameters.processId = processId;\n            context.addCleanup(cleanup);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ActionList, ActionsAction } from \"../../actions/ActionsAction\";\nimport { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { convertAction } from \"./convert-action\";\n\nexport async function convertActions<T>(\n        actions: ActionList<T>,\n        results: StepScript,\n        utils: Utils<T & ActionsAction<T>>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet) {\n    for (let a of actions) {\n        if (Array.isArray(a)) {\n            await convertActions(a, results, utils, external, convertorSet);\n        } else {\n            await convertAction(a, results, utils, external, convertorSet);\n        }\n    }\n}\n\nexport async function convertActionsProperty<T>(\n        action: ActionsAction<T>,\n        results: StepScript,\n        utils: Utils<T & ActionsAction<T>>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.actions?.length) {\n        return;\n    }\n    await convertActions(action.actions, results, utils, external, convertorSet);\n}\n","import { ActionsAction } from \"../../actions/ActionsAction\";\nimport { CallbackAction } from \"../../actions/CallbackAction\";\nimport { Context } from \"../../context/Context\";\nimport { ExecutionParameters, execute } from \"../../execution/ExecutionStep\";\nimport { calculateString } from \"../../resolutions/calculateString\";\nimport { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { convertActions } from \"./actions-convertor\";\nimport { convertAction } from \"./convert-action\";\nimport { newParams, recycleParams } from \"./parameter-utils\";\n\nexport async function convertCallbackProperty<T>(\n        action: CallbackAction<T>,\n        results: StepScript,\n        utils: Utils<T & CallbackAction<T>>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.callback) {\n        return;\n    }\n    const { callback, ...subAction } = action;\n\n    const callbackParameters: Record<string, ExecutionParameters | undefined> = {};\n    const executeCallback: Utils<T & CallbackAction<T>>[\"executeCallback\"] = { ...utils.executeCallback};\n    for (const key in callback) {\n        const callbackSteps: StepScript = new StepScript();\n        await convertActions(callback[key], callbackSteps, {...utils, executeCallback}, external, convertorSet);\n\n        const onCallback = callbackSteps.getSteps().length ? (context?: Context, additionalParameters?: ExecutionParameters) => { \n            const p = callbackParameters[key];\n            if (additionalParameters) {\n                if (p) {\n                    for (let k in additionalParameters) {\n                        p[k] = additionalParameters[k];\n                    }    \n                }\n            }\n            execute(callbackSteps, p, context);\n            for (let i in p) {\n                delete p[i];\n            }\n            if (p && context) {\n                recycleParams(p, context);\n                callbackParameters[key] = undefined;  \n            }\n        } : () => {};\n        executeCallback[key] = onCallback;\n    }\n\n    const subStepResults: StepScript = new StepScript();\n    await convertAction(subAction, subStepResults, { ...utils, executeCallback }, external, convertorSet);\n    results.add((parameters, context) => {\n        for (const key in callback) {\n            callbackParameters[key] = newParams(parameters, context);\n        }\n        execute(subStepResults, parameters, context);\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\nexport async function convertExecuteCallbackProperty<T>(\n        action: CallbackAction<T>,\n        results: StepScript,\n        utils: Utils<T & ActionsAction<T>>): Promise<ConvertBehavior | void> {\n    if (!action.executeCallback) {\n        return;\n    }\n    const { executeCallback } = action;\n\n    const callbackToExecute = calculateString(executeCallback);\n    results.add((parameters, context) => {\n        const callbackName = callbackToExecute.valueOf(parameters);\n        utils.executeCallback?.[callbackName]?.(context, parameters);\n    });\n}","import { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { execute } from \"../../execution/ExecutionStep\";\nimport { convertAction } from \"./convert-action\";\nimport { calculateBoolean } from \"../../resolutions/calculateBoolean\";\nimport { LogicAction } from \"../../actions/LogicAction\";\n\nexport async function convertConditionProperty<T>(\n        action: LogicAction,\n        results: StepScript,\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (action.condition === undefined) {\n        return;\n    }\n    if (!action.condition) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { condition, ...subAction } = action;\n    const conditionResolution = calculateBoolean(condition);\n    const subStepResults: StepScript = new StepScript();\n    await convertAction(subAction, subStepResults, utils, external, convertorSet);\n    results.add((parameters, context) => {\n        if (conditionResolution.valueOf(parameters)) {\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;        \n}\n","import { ExternalAction } from \"../../actions/ExternalAction\";\nimport { Resolution } from \"../../resolutions/Resolution\";\nimport { calculateResolution } from \"../../resolutions/calculate\";\nimport { calculateString } from \"../../resolutions/calculateString\";\nimport { ConvertBehavior, StepScript, Utils } from \"../Convertor\";\n\nexport async function convertExternalCallProperty<T>(\n        action: ExternalAction,\n        results: StepScript,\n        _: Utils<T & ExternalAction>,\n        external: Record<string, any>): Promise<ConvertBehavior|void> {\n    if (action.callExternal === undefined) {\n        return;\n    }\n    const { callExternal } = action;\n    const subjectResolution = calculateResolution(callExternal.subject);\n    const methodResolution = calculateString(callExternal.method);\n    const args: Resolution[] = !callExternal.arguments ? [] : Array.isArray(callExternal.arguments) ? callExternal.arguments : [callExternal.arguments];\n    const argsValues = args.map(m => calculateResolution(m));\n    results.add((parameters)=> {\n        const subject = subjectResolution?.valueOf(parameters) ?? external;\n        if (subject && typeof(subject) === \"object\" && !Array.isArray(subject)) {\n            const s = subject as Record<string, any>;\n            const method = methodResolution?.valueOf(parameters);\n            const m = s[method];\n            if (typeof(m) === \"function\") {\n                m.apply(s, argsValues.map(r => r?.valueOf(parameters)));\n            }    \n        }\n    });\n}\n","import { PauseAction } from \"../../actions/PauseAction\";\nimport { Context, ExecutionWithParams } from \"../../context/Context\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../../execution/ExecutionStep\";\nimport { calculateBoolean } from \"../../resolutions/calculateBoolean\";\nimport { calculateNumber } from \"../../resolutions/calculateNumber\";\nimport { calculateString } from \"../../resolutions/calculateString\";\nimport { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { convertAction } from \"./convert-action\";\n\nexport async function convertDelayProperty<T>(\n        action: PauseAction,\n        results: StepScript,\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.delay) {\n        return;\n    }\n\n    const { delay, ...subAction } = action;\n    const delayAmount = calculateNumber(delay);\n    const postStepResults: StepScript = new StepScript();\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, convertorSet);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, convertorSet);\n    }\n    const performPostSteps = (context: Context, parameters: ExecutionParameters) => {\n        execute(postStepResults, parameters, context);\n    }\n\n    results.add((parameters, context) => {\n        const timeout = external.setTimeout(performPostSteps, delayAmount.valueOf(parameters), context, parameters);\n        context.addCleanup(() => clearTimeout(timeout));\n    });\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertPauseProperty<T>(\n        action: PauseAction,\n        results: StepScript,\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.pause) {\n        return;\n    }\n\n    const { pause, ...subAction } = action;\n    const pauseResolution = calculateBoolean(pause);\n    const postStepResults: StepScript = new StepScript();\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, convertorSet);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, convertorSet);\n    }\n\n    // const step: ExecutionStep = (parameters, context) => {\n    //     for (let i in parameters) {\n    //         postExecution.parameters[i] = parameters[i];\n    //     }\n    //     if (!pauseResolution.valueOf(postExecution.parameters)) {\n    //         context.deletePostAction(postExecution);\n    //         execute(postStepResults, postExecution.parameters, context);\n    //     } else {\n    //         context.addPostAction(postExecution);\n    //     }\n    // };\n\n    // const postExecution: ExecutionWithParams = {\n    //     steps: [step],\n    //     parameters: {},\n    // };\n    const step: ExecutionStep = (parameters, context) => {\n        const postExecution: ExecutionWithParams = parameters.postAction ?? {\n            steps: [step],\n            parameters: {},\n        };\n        for (let i in parameters) {\n            postExecution.parameters[i] = parameters[i];\n        }\n        if (!pauseResolution.valueOf(postExecution.parameters)) {\n            context.deletePostAction(postExecution);\n            execute(postStepResults, postExecution.parameters, context);\n        } else {\n            context.addPostAction(postExecution);\n        }\n    };\n\n    results.add(step);\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertLockProperty<T>(\n        action: PauseAction,\n        results: StepScript,\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.lock && !action.unlock) {\n        return;\n    }\n\n    const { lock, unlock, ...subAction } = action;\n\n\n    if (unlock) {\n        const unlockResolution = calculateString(unlock);\n        results.add((parameters, context) => {\n            context.locked.delete(unlockResolution.valueOf(parameters));\n        });\n    }\n\n    if (lock) {\n        const lockResolution = calculateString(lock);\n        const postStepResults: StepScript = new StepScript();\n        const remainingActions = utils.getRemainingActions();\n        await convertAction(subAction, postStepResults, utils, external, convertorSet);\n        for (let action of remainingActions) {\n            await convertAction(action, postStepResults, utils, external, convertorSet);\n        }\n\n        results.add((parameters, context) => {\n            const lockId = lockResolution.valueOf(parameters);\n            context.locked.add(lockId);\n            const step: ExecutionStep = (parameters, context) => {\n                for (let i in parameters) {\n                    postExecution.parameters[i] = parameters[i];\n                }\n                if (!context.locked.size) {\n                    context.deletePostAction(postExecution);\n                    execute(postStepResults, parameters, context);    \n                }\n            };\n            const postExecution: ExecutionWithParams = {\n                steps: [step],\n                parameters,\n            };\n    \n            context.addPostAction(postExecution);\n        });\n        return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n    }\n}","import { SetAction } from \"../../actions/SetAction\";\nimport { SupportedTypes } from \"../../resolutions/SupportedTypes\";\nimport { calculateResolution } from \"../../resolutions/calculate\";\nimport { calculateString } from \"../../resolutions/calculateString\";\nimport { ValueOf } from \"../../types/ValueOf\";\nimport { ConvertBehavior, StepScript } from \"../Convertor\";\nimport { newParams, recycleParams } from \"./parameter-utils\";\n\nexport async function convertSetProperty(\n        action: SetAction,\n        results: StepScript): Promise<ConvertBehavior|void> {\n    if (!action.set) {\n        return;\n    }\n    const { set } = action;\n    const variable = calculateString(set.variable);\n    const access = [variable, ...(set.access?.map(a => calculateResolution(a)) ?? [])];\n    const value = calculateResolution(set.value);\n\n    results.add((parameters)=> {\n        let root: any = parameters;\n        for (let i = 0; i < access.length; i++) {\n            if (!root) {\n                console.warn(\"Invalid access\");\n                return;\n            }\n            const key = access[i]?.valueOf(parameters);\n            if (Array.isArray(root)) {\n                if (typeof key === \"number\") {\n                    if (i === access.length - 1) {\n                        parameters.value = root[key];\n                        root[key] = value?.valueOf(parameters);\n                    } else {\n                        root = root[key];\n                    }\n                } else {\n                    console.warn(\"Invalid key for array: \", key);\n                }\n            } else if (typeof(root) === \"object\") {\n                if (i === access.length - 1) {\n                    parameters.value = root[key + \"\"];\n                    root[key + \"\"] = value?.valueOf(parameters);\n                } else {\n                    root = root[key + \"\"];\n                }\n            }    \n        }\n    });    \n}\n\nexport async function convertSetsProperty(\n        action: SetAction,\n        results: StepScript): Promise<ConvertBehavior|void> {\n    if (!action.sets) {\n        return;\n    }\n    const { sets } = action;\n    const setsEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = !sets ? [] : Object.entries(sets).map(([key, value]) => [key, calculateResolution(value)]);\n\n    results.add((parameters, context)=> {\n        const paramsTemp = newParams(undefined, context);\n\n        for (const [key, value] of setsEntries) {\n            parameters.value = parameters[key];\n            paramsTemp[key] = value?.valueOf(parameters);    \n        }\n        delete parameters.value;\n        for (const [key] of setsEntries) {\n            parameters[key] = paramsTemp[key];\n        }\n        recycleParams(paramsTemp, context);\n    });    \n}\n\nexport async function convertDefaultValuesProperty(\n    action: SetAction,\n    results: StepScript): Promise<ConvertBehavior|void> {\nif (!action.defaultValues) {\n    return;\n}\nconst { defaultValues } = action;\nconst defaultValuesEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = !defaultValues ? [] : Object.entries(defaultValues).map(([key, value]) => [key, calculateResolution(value)]);\n\nresults.add((parameters, context)=> {\n    const paramsTemp = newParams(undefined, context);\n\n    for (const [key, value] of defaultValuesEntries) {\n        parameters.value = parameters[key];\n        paramsTemp[key] = value?.valueOf(parameters);    \n    }\n    delete parameters.value;\n    for (const [key] of defaultValuesEntries) {\n        if (parameters[key] === undefined) {\n            parameters[key] = paramsTemp[key];\n        }\n    }\n    recycleParams(paramsTemp, context);\n});    \n}\n","import { HookAction } from \"../../actions/HookAction\";\nimport { StringResolution } from \"../../resolutions/StringResolution\";\nimport { calculateString } from \"../../resolutions/calculateString\";\nimport { ValueOf } from \"../../types/ValueOf\";\nimport { ConvertBehavior, StepScript, Utils } from \"../Convertor\";\n\nexport async function convertHooksProperty<T>(\n        action: HookAction & T,\n        results: StepScript,\n        _: Utils<T & HookAction>,\n        external: Record<string, any>): Promise<ConvertBehavior|void> {\n    if (!action.hooks) {\n        return;\n    }\n    const { hooks } = action;\n\n    const hooksResolution: StringResolution[] = hooks;\n    const hooksValueOf: ValueOf<string>[] = hooksResolution.map(hook => calculateString(hook));\n\n    results.add((parameters) => {\n        for (let hook of hooksValueOf) {\n            const h = hook.valueOf(parameters);\n            const x = external[h];\n            if (x) {\n                parameters[h] = x;\n            } else {\n                console.warn(\"Does not exist\", x);\n            }\n        }\n    });\n}\n","import { LogAction } from \"../../actions/LogAction\";\nimport { Resolution } from \"../../resolutions/Resolution\";\nimport { calculateResolution } from \"../../resolutions/calculate\";\nimport { ConvertBehavior, StepScript, Utils } from \"../Convertor\";\n\nexport async function convertLogProperty<T>(\n        action: LogAction,\n        results: StepScript,\n        _: Utils<T>,\n        external: Record<string, any>): Promise<ConvertBehavior|void> {\n    if (action.log === undefined) {\n        return;\n    }\n    const messages: Resolution[] = Array.isArray(action.log) ? action.log : [action.log];\n    const resolutions = messages.map(m => calculateResolution(m));\n    results.add((parameters)=> external.log(...resolutions.map(r => r?.valueOf(parameters))));    \n}\n","import { ExecutionParameters, execute } from \"../../execution/ExecutionStep\";\nimport { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { calculateNumber } from \"../../resolutions/calculateNumber\";\nimport { convertAction } from \"./convert-action\";\nimport { LogicAction } from \"../../actions/LogicAction\";\nimport { Context } from \"../../context/Context\";\nimport { ValueOf } from \"../../types/ValueOf\";\nimport { calculateBoolean } from \"../../resolutions/calculateBoolean\";\nimport { calculateArray } from \"../../resolutions/calculateArray\";\n\nconst VARIABLE_NAMES = \"ijklmnopqrstuvwxyzabcdefgh\".split(\"\");\n\nfunction keepLooping(parameters: ExecutionParameters, context: Context, loops: ValueOf<number>[], steps: StepScript, depth: number = 0, base: number = 0) {\n    if (depth >= loops.length) {\n        execute(steps, parameters, context);\n        return;\n    }\n    const length = loops[depth].valueOf(parameters);\n    const p = parameters;\n    const letter = VARIABLE_NAMES[depth];\n    const subBase = base * length;\n    for (let i = 0; i < length; i++) {\n        p[letter] = i;\n        p.loopIndex = subBase + i;\n        keepLooping(p, context, loops, steps, depth + 1, subBase + i);\n    }\n}\n\nexport async function convertLoopProperty<T>(\n        action: T & LogicAction,\n        stepResults: StepScript,\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (action.loop === undefined) {\n        return;\n    }\n    if (!action.loop) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { loop, ...subAction } = action;\n    const loops = Array.isArray(loop) ? loop: [loop];\n    if (!loops.length) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const loopResolution = loops.map(loop => calculateNumber(loop, 0));\n    const subStepResults: StepScript = new StepScript();\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, convertorSet);\n    stepResults.add((parameters, context) =>  keepLooping(parameters, context, loopResolution, subStepResults));\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\nexport async function convertWhileProperty<T>(\n        action: T & LogicAction,\n        stepResults: StepScript,\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (action.whileCondition === undefined) {\n        return;\n    }\n    if (!action.whileCondition) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { whileCondition, ...subAction } = action;\n    const whileResolution = calculateBoolean(whileCondition);\n    const subStepResults: StepScript = new StepScript();\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, convertorSet);\n    stepResults.add((parameters, context) =>  {\n        while(whileResolution.valueOf(parameters)) {\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\nexport async function convertLoopEachProperty<T>(\n        action: T & LogicAction,\n        stepResults: StepScript,\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (action.loopEach === undefined) {\n        return;\n    }\n    const { loopEach, ...subAction } = action;\n    const loopEachResolution = calculateArray(loopEach);\n    const subStepResults: StepScript = new StepScript();\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, convertorSet);\n    stepResults.add((parameters, context) =>  {\n        const array = loopEachResolution?.valueOf(parameters);\n        if (array) {\n            for (let i = 0; i < array.length; i++) {\n                parameters.loopIndex = i;\n                parameters.element = array[i];\n                execute(subStepResults, parameters, context);\n            }\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}","import { ConvertBehavior, ConvertorSet, StepScript, Utils } from \"../Convertor\";\nimport { calculateResolution } from \"../../resolutions/calculate\";\nimport { ValueOf } from \"../../types/ValueOf\";\nimport { ExecutionParameters, execute } from \"../../execution/ExecutionStep\";\nimport { convertAction } from \"./convert-action\";\nimport { SupportedTypes } from \"../../resolutions/SupportedTypes\";\nimport { ScriptAction } from \"../../actions/ScriptAction\";\nimport { newParams, recycleParams } from \"./parameter-utils\";\n\nexport async function convertParametersProperty<T>(\n        action: ScriptAction,\n        results: StepScript,\n        utils: Utils<T & ScriptAction>,\n        external: Record<string, any>,\n        convertorSet: ConvertorSet): Promise<ConvertBehavior | void> {\n    if (!action.parameters) {\n        return;\n    }\n    const { parameters, ...subAction } = action;\n\n    const paramEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = Object.entries(parameters ?? {})\n        .map(([key, resolution]) => [key, calculateResolution(resolution)]);\n    \n    const subStepResults: StepScript = new StepScript();\n    await convertAction(subAction, subStepResults, utils, external, convertorSet);\n\n    results.add((parameters, context) => {\n        const paramValues: ExecutionParameters = newParams(undefined, context);\n        for (let entry of paramEntries) {\n            const key: string = entry[0];\n            paramValues[key] = entry[1]?.valueOf(parameters);\n        }\n\n        execute(subStepResults, paramValues, context);\n\n        recycleParams(paramValues, context);\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ScriptAction } from \"../../actions/ScriptAction\";\nimport { execute } from \"../../execution/ExecutionStep\";\nimport { ConvertBehavior, StepScript, Utils } from \"../Convertor\";\n\nexport async function convertScriptProperty<T>(\n        action: ScriptAction,\n        results: StepScript,\n        {getSteps}: Utils<T>): Promise<ConvertBehavior|void> {\n    if (!action.executeScript) {\n        return;\n    }\n    const { executeScript } = action;\n\n    const name = executeScript;\n    const steps = getSteps({ name });\n    results.add((parameters, context) => execute(steps, parameters, context));\n}\n\n","import { ConvertorSet } from \"./Convertor\";\nimport { convertActionsProperty } from \"./actions/actions-convertor\";\nimport { convertCallbackProperty, convertExecuteCallbackProperty } from \"./actions/callback-convertor\";\nimport { convertConditionProperty } from \"./actions/condition-convertor\";\nimport { convertExternalCallProperty } from \"./actions/convert-external-call\";\nimport { convertDelayProperty, convertLockProperty, convertPauseProperty } from \"./actions/convert-pause\";\nimport { convertDefaultValuesProperty, convertSetProperty, convertSetsProperty } from \"./actions/convert-set\";\nimport { convertHooksProperty } from \"./actions/hooks-convertor\";\nimport { convertLogProperty } from \"./actions/log-convertor\";\nimport { convertLoopEachProperty, convertLoopProperty } from \"./actions/loop-convertor\";\nimport { convertParametersProperty } from \"./actions/parameters-convertor\";\nimport { convertRefreshProperty } from \"./actions/refresh-convertor\";\nimport { convertScriptProperty } from \"./actions/script-convertor\";\n\nexport function getDefaultConvertors(): ConvertorSet {\n    return {\n        actionsConvertor: [\n            convertHooksProperty,\n            convertParametersProperty,\n            convertDefaultValuesProperty,\n            convertRefreshProperty,\n            convertLoopEachProperty,\n            convertLoopProperty,\n            convertConditionProperty,\n            convertCallbackProperty,\n            convertDelayProperty,\n            convertPauseProperty,\n            convertLockProperty,\n            convertSetProperty,\n            convertSetsProperty,\n            convertExecuteCallbackProperty,\n            convertExternalCallProperty,\n            convertLogProperty,\n            convertScriptProperty,\n            convertActionsProperty,\n        ],\n    };\n}\n","import { Context, createContext } from \"../context/Context\";\nimport { ConvertorSet, StepScript } from \"../convertor/Convertor\";\nimport { DEFAULT_REFRESH_FRAME_RATE } from \"../convertor/actions/refresh-convertor\";\nimport { getDefaultConvertors } from \"../convertor/default-convertors\";\nimport { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { convertScripts } from \"../convertor/utils/script-utils\";\nimport { ExecutionParameters, execute } from \"../execution/ExecutionStep\";\nimport { Script, ScriptFilter, Tag, filterScripts } from \"../scripts/Script\";\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface RefreshBehavior {\n    frameRate?: number;\n    cleanupAfterRefresh?: boolean;\n    parameters?: ExecutionParameters;\n}\n\nexport interface ScriptProcessorHelper {\n    refreshSteps(steps: StepScript, behavior?: RefreshBehavior, processId?: string): { cleanup: () => void; processId: string };\n    stopRefresh(processId: string): void;\n}\n\nexport class ScriptProcessor<T, E = {}> {\n    private scripts: Script<T>[];\n    private scriptMap?: Map<Script<T>, StepScript>;\n    private external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    private convertorSet: ConvertorSet;\n    private refreshCleanups: Record<string, () => void> = {};\n\n    constructor(scripts: Script<T>[], external = {}, convertorSet: ConvertorSet = getDefaultConvertors()) {\n        this.scripts = scripts;\n        this.convertorSet = convertorSet;\n        this.external = {...DEFAULT_EXTERNALS, ...external};\n    }\n\n    updateScripts(scripts: Script<T>[]) {\n        this.clear();\n        this.scripts = scripts;\n        this.scriptMap = undefined;\n    }\n\n    clear() {\n        Object.values(this.refreshCleanups).forEach(cleanup => cleanup());\n        Object.keys(this.refreshCleanups).forEach(key => delete this.refreshCleanups[key]);\n    }\n\n    private async fetchScripts(): Promise<Map<Script<T>, StepScript>> {\n        if (!this.scriptMap) {\n            this.scriptMap = await convertScripts(this.scripts, this.external, this.convertorSet, {\n                refreshSteps: this.refreshSteps.bind(this),\n                stopRefresh: this.stopRefresh.bind(this),\n            });\n        }\n        return this.scriptMap!;\n    }\n\n    private createRefreshCleanup(behavior: RefreshBehavior, context: Context) {\n        return behavior.cleanupAfterRefresh ? () => context.cleanup() : () => {};\n    }\n\n    async getSteps(filter: ScriptFilter) {\n        const scriptMap = await this.fetchScripts();\n        const scripts = filterScripts(this.scripts, filter);\n        const steps: StepScript = new StepScript();\n        scripts.forEach(script => scriptMap.get(script)?.getSteps().forEach(step => steps.add(step)));\n        return steps;\n    }\n\n    async runByName(name: string, parameters: ExecutionParameters = {}) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ name }), {\n            ...parameters,\n            time: undefined,\n            index: undefined,\n        }, context);\n        return () => context.clear();\n    }\n\n    async runByTags(tags: Tag[], parameters: ExecutionParameters = {}) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ tags }), {\n            ...parameters,\n            time: undefined,\n            index: undefined,\n        }, context);\n        return () => context.clear();\n    }\n\n    private async refreshWithFilter(filter: ScriptFilter, behavior: RefreshBehavior = {}) {\n        return this.refreshSteps(await this.getSteps(filter), behavior);\n    }\n\n    private stopRefresh(processId: string) {\n        this.refreshCleanups[processId]?.();\n        delete this.refreshCleanups[processId];\n    }\n    \n    private refreshSteps(steps: StepScript, behavior: RefreshBehavior = {}, processId?: string) {\n        const context: Context = createContext();\n        const parameters: ExecutionParameters = { ...behavior.parameters, time: 0, frame: 0 };\n        const refreshCleanup = this.createRefreshCleanup(behavior, context);\n        const frameRate = behavior.frameRate ?? DEFAULT_REFRESH_FRAME_RATE;\n        const frameMs = 1000 / frameRate;\n        let lastFrameTime = Number.MIN_SAFE_INTEGER;\n        let frame = 0;\n        const loop = (time: number) => {\n            if (time >= lastFrameTime + frameMs) {\n                parameters.time = time;\n                parameters.frame = frame;\n                execute(steps, parameters, context);\n                refreshCleanup();\n                frame++;\n                lastFrameTime = time;\n            }\n            animationFrameId = requestAnimationFrame(loop);\n        };\n        let animationFrameId = requestAnimationFrame(loop);\n        const cleanup = () => {\n            refreshCleanup();\n            cancelAnimationFrame(animationFrameId);\n        }\n        const actualProcessId = processId ?? uuidv4();\n        //  cleanup previous process if it exists.\n        this.refreshCleanups[actualProcessId]?.();\n\n        this.refreshCleanups[actualProcessId] = cleanup;\n\n        return { processId: actualProcessId, cleanup };\n    }\n    \n    refreshByName(name: string, behavior: RefreshBehavior = {}) {\n        return this.refreshWithFilter({ name }, behavior);\n    }\n\n    refreshByTags(tags: string[], behavior: RefreshBehavior = {}) {\n        return this.refreshWithFilter({ tags }, behavior);\n    }\n}"],"names":["DEFAULT_EXTERNALS","log","console","setTimeout","clearTimeout","fetch","global","ObjectPool","factory","cleanup","_proto","prototype","generate","_this$pool$pop","pool","pop","recycle","value","push","Context","_temp","_ref$parameters","_ref","parameters","_ref$cleanupActions","cleanupActions","_ref$objectPool","objectPool","k","_ref$postActionListen","postActionListener","Set","_ref$external","external","_extends","locked","addCleanup","addPostAction","postAction","has","add","deletePostAction","executePostActions","forEach","listener","i","steps","step","_this","action","length","clear","createContext","_temp2","_ref2$parameters","_ref2","_ref2$cleanupActions","_ref2$objectPool","_ref2$postActionListe","_ref2$external","ConvertBehavior","StepScript","getSteps","execute","context","params","changedParameters","_iterator","_createForOfIteratorHelperLoose","_step","done","filterMatchesTags","filter","tags","_filter$tags","every","tag","some","t","Array","isArray","filterScripts","scripts","filterScriptsHelper","namesToFilter","name","undefined","indexOf","convertScriptsHelper","convertorSet","processorHelper","scriptMap","Map","script","set","filteredScripts","stepScript","get","_forOf","_scriptMap$get","_interrupt","scriptSteps","_script$actions","actions","_forTo","getRemainingActions","slice","Promise","resolve","convertAction","refreshSteps","stopRefresh","then","convertBehavior","SKIP_REMAINING_ACTIONS","e","reject","convertScripts","spreadScripts","results","executeAction","utils","_ConvertBehavior$SKIP","_convertAction","executeScript","scriptName","find","stepResults","actionsConvertor","convertor","SKIP_REMAINING_CONVERTORS","_exit","newParams","recycleParams","FORMULA_SEPARATORS","hasFormula","resolution","isFormula","item","Object","values","keys","formula","_FORMULA_SEPARATORS$m","map","char","startCharacter","prefix","suffix","getInnerFormulas","substring","split","chunk","index","textSuffix","_chunk$split","IDENTIFIER_REGEX","isSimpleInnerFormula","innerFormula","test","calculateEvaluator","evaluator","defaultValue","scope","_evaluator$evaluate","evaluate","error","getEvaluator","mathEvaluator","math","compile","_scope$formula","getFormulaEvaluator","Error","evaluators","join","calculateArray","array","valueOf","calculateResolution","evalItem","calculateMap","evaluatorEntries","entries","key","fromEntries","calculateObject","subject","access","_value$access","node","_node2","_node3","_node","Float32Array","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","calculateNumber","calculateString","calculateBoolean","convertValueOf","val","getGlType","type","glType","WebGL2RenderingContext","BYTE","FLOAT","SHORT","UNSIGNED_BYTE","UNSIGNED_SHORT","INT","UNSIGNED_INT","getTypedArray","getByteSize","typeArray","calculateTypeArrayConstructor","BYTES_PER_ELEMENT","getTypeArrayContructor","glTypeValueOf","calculateTypedArray","typedArrayContructor","ArrayConstructor","compiledArray","bufferArray","convertRefreshProperty","refresh","subAction","_objectWithoutPropertiesLoose","_excluded","subStepResults","processIdValue","processId","stop","cleanupAfterRefresh","frameRate","DEFAULT_REFRESH_FRAME_RATE","_utils$refreshSteps","convertActionsProperty","_action$actions","convertActions","a","convertExecuteCallbackProperty","executeCallback","callbackToExecute","callbackName","_utils$executeCallbac","_utils$executeCallbac2","call","convertCallbackProperty","callback","callbackParameters","_forIn","callbackSteps","onCallback","additionalParameters","p","convertConditionProperty","condition","conditionResolution","convertExternalCallProperty","_","callExternal","subjectResolution","methodResolution","method","args","arguments","argsValues","m","_subjectResolution$va","s","apply","r","convertLockProperty","lock","unlock","_excluded3","unlockResolution","lockResolution","postStepResults","remainingActions","_temp6","lockId","postExecution","size","_temp5","convertPauseProperty","pause","_excluded2","pauseResolution","_temp4","_parameters$postActio","_temp3","convertDelayProperty","delay","delayAmount","performPostSteps","timeout","convertDefaultValuesProperty","defaultValues","defaultValuesEntries","paramsTemp","_iterator3","_step3","_step3$value","_iterator4","_step4","_step4$value","convertSetsProperty","sets","setsEntries","_step$value","_iterator2","_step2","_step2$value","convertSetProperty","variable","concat","_set$access$map","_set$access","root","_access$i","warn","convertHooksProperty","hooks","hooksResolution","hooksValueOf","hook","h","x","convertLogProperty","messages","resolutions","convertLoopEachProperty","loopEach","loopEachResolution","loopIndex","element","convertLoopProperty","loop","loops","loopResolution","keepLooping","VARIABLE_NAMES","depth","base","letter","subBase","convertParametersProperty","paramEntries","paramValues","_entry$","entry","convertScriptProperty","getDefaultConvertors","ScriptProcessor","updateScripts","refreshCleanups","fetchScripts","_this2","bind","_convertScripts","createRefreshCleanup","behavior","_this3","runByName","_this4","_this4$getSteps","time","runByTags","_this5","_this5$getSteps","refreshWithFilter","_refreshSteps","_this6","_this6$getSteps","_this$refreshCleanups","_this$refreshCleanups2","frame","refreshCleanup","_behavior$frameRate","frameMs","lastFrameTime","Number","MIN_SAFE_INTEGER","animationFrameId","requestAnimationFrame","cancelAnimationFrame","actualProcessId","uuidv4","_this$refreshCleanups3","_this$refreshCleanups4","refreshByName","refreshByTags"],"mappings":"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"}