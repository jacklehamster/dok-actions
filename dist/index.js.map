{"version":3,"file":"index.js","sources":["../src/core/convertor/default-externals.ts","../src/core/context/Context.ts","../src/core/convertor/Convertor.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/core/execution/ExecutionStep.ts","../src/core/scripts/Script.ts","../src/core/convertor/convert-action.ts","../src/core/resolutions/calculateEvaluator.ts","../src/core/resolutions/calculateArray.ts","../src/core/resolutions/calculateMap.ts","../src/core/resolutions/calculate.ts","../src/core/resolutions/calculateNumber.ts","../src/core/resolutions/calculateString.ts","../src/core/resolutions/calculateBoolean.ts","../src/core/resolutions/calculateTypeArray.ts","../src/core/convertor/actions-convertor.ts","../src/core/convertor/condition-convertor.ts","../src/core/convertor/convert-pause.ts","../src/core/convertor/convert-reference.ts","../src/core/convertor/log-convertor.ts","../src/core/convertor/loop-convertor.ts","../src/core/convertor/parameters-convertor.ts","../src/core/convertor/script-convertor.ts","../src/core/convertor/default-convertors.ts","../src/core/processor/ScriptProcessor.ts"],"sourcesContent":["export const DEFAULT_EXTERNALS = {\n    log: console.log,\n    setTimeout,\n    clearTimeout,\n    fetch: global.fetch,\n};\n","import { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { ExecutionParameters, ExecutionStep } from \"../execution/ExecutionStep\";\n\nexport interface Context<E = {}> {\n    parameters: ExecutionParameters[];\n    cleanupActions:(() => void)[];\n    objectPool: ExecutionParameters[];\n    postActionListener: Set<ExecutionStep>;\n    external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    locked: boolean;\n}\n\nexport function createContext<E>({\n        parameters = [],\n        cleanupActions = [],\n        objectPool = [],\n        postActionListener = new Set(),\n        external = {},\n}: {\n    parameters?: ExecutionParameters[];\n    cleanupActions?:(() => void)[];\n    objectPool?: ExecutionParameters[];\n    postActionListener?: Set<ExecutionStep>;\n    external?: E | {};\n} = {}): Context<E|{}> {\n    return {\n        parameters,\n        cleanupActions,\n        objectPool,\n        postActionListener,\n        external: {...DEFAULT_EXTERNALS, ...external},\n        locked: false,\n    };\n}","import { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { ScriptFilter } from \"../scripts/Script\";\nimport { ActionConvertorList } from \"./convert-action\";\n\nexport type GetSteps = (filter: ScriptFilter) => ExecutionStep[];\n\nexport enum ConvertBehavior {\n    NONE,\n    SKIP_REMAINING_CONVERTORS,\n    SKIP_REMAINING_ACTIONS,\n}\n\nexport interface Utils<T> {\n    getSteps: GetSteps;\n    getRemainingActions: () => T[]; \n}\n\nexport type Convertor<T> = (action: T, results: ExecutionStep[], utils: Utils<T>, external: Record<string, any>, actionConversionMap: ActionConvertorList) => Promise<ConvertBehavior | void>;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Context, createContext } from \"../context/Context\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\n\nexport type ExecutionParameters = Record<string, SupportedTypes>;\nexport type ExecutionStep = (context: Context, parameters: ExecutionParameters) => void;\n\nexport function execute(steps?: ExecutionStep[], parameters: ExecutionParameters = {}, context: Context = createContext()) {\n    if (!steps?.length) {\n        return;\n    }\n    if (!context.parameters) {\n        context.parameters = [];\n    }\n\n    const params = context.parameters;\n    const changedParameters = params[params.length-1] !== parameters;\n    if (changedParameters) {\n        params.push(parameters);\n    }\n    for (let step of steps) {\n        step(context, parameters);\n    }\n    context.postActionListener.forEach(listener => listener(context, parameters));\n\n    if (changedParameters) {\n        params.pop();\n    }\n}\n","import { DokAction } from \"../actions/Action\";\nimport { Resolution } from \"../resolutions/Resolution\";\n\nexport type Tag = string|[string, string|number|boolean];\n\nexport interface Script<T> {\n    name?: string;\n    parameters?: (string|[string, Resolution])[];\n    actions: (T & DokAction<T>)[];\n    tags?: Tag[];\n}\n\nexport interface ScriptFilter {\n    name?: string | string[];\n    tags?: Tag[];\n}\n\nfunction filterMatchesTags(filter: ScriptFilter, tags?: Tag[]) {\n    return filter.tags?.every(tag => {\n        if (typeof(tag) === \"string\") {\n            return tags?.some((t) => t === tag || (Array.isArray(t) && t[0] === tag));\n        } else {\n            return tags?.some((t) => Array.isArray(t) && t[0] === tag[0] && t[1] === tag[1]);\n        }\n    });\n}\n\nexport function filterScripts<T>(scripts: Script<T>[], filter: ScriptFilter): Script<T>[] {\n    const namesToFilter = !filter.name ? undefined : Array.isArray(filter.name) ? filter.name : [filter.name];\n    return scripts.filter(({name, tags}) => {\n        if (namesToFilter?.length && namesToFilter.indexOf(name ?? \"\") < 0) {\n            return false;\n        }    \n        if (filter.tags && !filterMatchesTags(filter, tags)) {\n            return false;\n        }\n        return true;\n    });\n}\n","import { Context, createContext } from \"../context/Context\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { Script, ScriptFilter, filterScripts } from \"../scripts/Script\";\nimport { ConvertBehavior, Convertor, Utils } from \"./Convertor\";\n\nexport type ActionConvertorList = Convertor<any>[];\n\nexport async function convertAction<T>(\n        action: T,\n        stepResults: ExecutionStep[],\n        utils: Utils<T>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    for (let convertor of actionConversionMap) {\n        const convertBehavior = await convertor(action, stepResults, utils, external, actionConversionMap);\n        if (convertBehavior === ConvertBehavior.SKIP_REMAINING_CONVERTORS) {\n            return;\n        } else if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n            return convertBehavior;\n        }\n    }\n    return;    \n}\n\nexport async function convertScripts<T>(\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<Map<Script<T>, ExecutionStep[]>> {\n    const scriptMap: Map<Script<T>, ExecutionStep[]> = new Map();\n    const getSteps = (filter: ScriptFilter) => {\n        const filteredScripts = filterScripts(scripts, filter);\n        const steps: ExecutionStep[] = [];\n        filteredScripts.forEach(script => steps.push(...(scriptMap.get(script)??[])));\n        return steps;\n    };\n    for (let script of scripts) {\n        if (!scriptMap.has(script)) {\n            scriptMap.set(script, []);\n        }\n        const scriptSteps = scriptMap.get(script) ?? [];\n        const { actions } = script;\n        for (let i = 0; i < actions.length; i++) {\n            const getRemainingActions = () => actions.slice(i + 1);\n            const convertBehavior = await convertAction(actions[i], scriptSteps, {getSteps, getRemainingActions}, external, actionConversionMap);\n            if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n                break;\n            }\n        }\n    }\n    return scriptMap;\n}\n\nexport async function executeScript<T>(\n        scriptName: string,\n        parameters: ExecutionParameters = {},\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<() => void> {\n    const context: Context = createContext();\n    const scriptMap = await convertScripts(scripts, external, actionConversionMap);\n    const script = scripts.find(({name}) => name === scriptName);\n    const steps = script ? scriptMap.get(script) : [];\n    execute(steps, parameters, context);\n    return () => {\n        context.cleanupActions!.forEach(action => action());\n        context.cleanupActions!.length = 0;\n    };\n}\n\nexport function executeAction<T>(\n        action: T,\n        parameters: ExecutionParameters,\n        context: Context,\n        utils: Utils<T>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): void {\n    const results: ExecutionStep[] = [];\n    convertAction(action, results, utils, external, actionConversionMap);\n    execute(results, parameters, context);\n}","import * as math from \"mathjs\";\nimport { Context } from \"../context/Context\";\nimport { Expression, Formula } from \"./Formula\";\nimport { Resolution } from \"./Resolution\";\n\nexport function hasFormula(resolution: Resolution): boolean {\n    if (isFormula(resolution)) {\n        return true;\n    }\n    if (Array.isArray(resolution)) {\n        return resolution.some(item => hasFormula(item));\n    }\n    if (typeof (resolution) === \"object\") {\n        return hasFormula(Object.values(resolution));\n    }\n    return false;\n}\n\nexport function isFormula(value: Formula | Expression | any) {\n    if (!value) {\n        return false;\n    }\n    if (typeof(value) !== \"string\" && typeof(value) !== \"object\") {\n        return false;\n    }\n    const formula = typeof(value) === \"string\" ? value : value.formula;\n    return formula?.charAt(0) === \"{\" && formula?.charAt(formula.length-1) === \"}\";\n}\n\nexport function calculateEvaluator<T>(evaluator: math.EvalFunction, context: Context | undefined, formula: Formula | Expression, defaultValue: T): T {\n    const scope = context?.parameters?.[context.parameters.length - 1];\n    try {\n        return evaluator.evaluate(scope ?? {}) ?? defaultValue;\n    } catch (e) {\n        console.error(\"Error: \" + e + \" on formula: \" + formula + \", scope: \", scope);\n    }\n    return defaultValue;\n}\n\nexport function getFormulaEvaluator(value: Formula | Expression): math.EvalFunction {\n    if (!isFormula(value)) {\n        throw new Error(`Formula: ${value} must start and end with brackets.`);\n    }\n    const formula = typeof(value) === \"string\" ? value : value.formula;\n    const mathEvaluator = math.parse(formula.substring(1, formula.length - 1)).compile();\n    return mathEvaluator;\n}\n\n","import { Context } from \"../context/Context\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ArrayResolution } from \"./ArrayResolution\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator, hasFormula, isFormula } from \"./calculateEvaluator\";\nimport { Expression, Formula } from \"./Formula\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\n\nexport function calculateArray(value: ArrayResolution): ValueOf<SupportedTypes> | undefined {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        if (!Array.isArray(value)) {\n            throw new Error(\"value is not an array\");\n        }\n        const array = value as SupportedTypes[];\n        return { valueOf: () => array };\n    }\n    if (!value) {\n        return undefined;\n    }\n    if (isFormula(value)) {\n        const formula = value as (Formula|Expression);\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(context?: Context): SupportedTypes[] | undefined {\n                return calculateEvaluator<SupportedTypes[] | undefined>(evaluator, context, formula, undefined);\n            }\n        };\n    }\n    const array = value as Resolution[]\n\n    const evaluator = array.map(resolution => calculateResolution(resolution));\n\n    return {\n        valueOf(context?: Context): SupportedTypes {\n            const value = evaluator.map(evalItem => evalItem?.valueOf(context));\n            return value;\n        }\n    };\n}","import { Context } from \"../context/Context\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator, hasFormula, isFormula } from \"./calculateEvaluator\";\nimport { Expression, Formula } from \"./Formula\";\nimport { MapResolution } from \"./MapResolution\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\n\nexport function calculateMap(value: MapResolution): ValueOf<{ [key:string]:SupportedTypes } | undefined> {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        const map = value as {[key: string]:SupportedTypes}\n        return { valueOf: () => map };\n    }\n    if (isFormula(value)) {\n        const formula = value as (Formula|Expression);\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(context?: Context): { [key:string]:SupportedTypes } | undefined {\n                return calculateEvaluator<{ [key:string]:SupportedTypes } | undefined>(evaluator, context, formula, undefined);\n            }\n        };\n    }\n    const map = value as {[key: string]:Resolution}\n    const evaluatorEntries = Object.entries(map).map(([key, resolution]) => [key, calculateResolution(resolution)]);\n\n    return {\n        valueOf(context?: Context): { [key:string]:SupportedTypes } | undefined {\n            return Object.fromEntries(evaluatorEntries.map(([key, evalItem]) => [key, evalItem?.valueOf(context)]));\n        }\n    };\n}","import { Context } from \"../context/Context\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { Resolution } from \"./Resolution\";\nimport { calculateArray } from \"./calculateArray\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./calculateEvaluator\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { calculateMap } from \"./calculateMap\";\n\nexport function calculateResolution(value: Resolution): ValueOf<SupportedTypes> | undefined {\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return undefined;\n            }\n        };\n    }\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n    if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return value;\n    }\n    if (typeof(value) === \"string\" && (value.charAt(0) !== \"{\" || value.charAt(value.length-1) !== \"}\")) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return calculateArray(value);\n    }\n    if (typeof(value) === \"object\") {\n        return calculateMap(value);\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(context?: Context): string | number | undefined {\n            return calculateEvaluator<string | number | undefined>(evaluator, context, value, undefined);\n        }\n    };\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { Context } from \"../context/Context\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./calculateEvaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\n\n\nexport function calculateNumber<T extends number = number>(value: NumberResolution<T>, defaultValue:T|0 = 0): ValueOf<T|0>|number {\n    if (typeof(value) === \"number\") {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(context?: Context): T|0 {\n            return calculateEvaluator<T|0>(evaluator, context, value, defaultValue);\n        }\n    };\n}\n","import { Context } from \"../context/Context\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { StringResolution } from \"./StringResolution\";\nimport { calculateEvaluator, getFormulaEvaluator, isFormula } from \"./calculateEvaluator\";\n\nexport function calculateString<T extends string = string>(value: StringResolution<T>, defaultValue: T|\"\" = \"\"): ValueOf<T|\"\">|string {\n    if (typeof(value) === \"string\" && !isFormula(value)) {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(context?: Context): T|\"\" {\n            return calculateEvaluator<T|\"\">(evaluator, context, value, defaultValue);\n        }\n    };\n\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { Context } from \"../context/Context\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./calculateEvaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\nimport { BooleanResolution } from \"./BooleanResolution\";\n\nexport function calculateBoolean(value: BooleanResolution | NumberResolution, defaultValue = false): ValueOf<boolean> {\n    if (typeof(value) === \"boolean\" || typeof(value) === \"number\") {\n        return !!value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(context?: Context): boolean {\n            return !!calculateEvaluator<boolean | number>(evaluator, context, value, defaultValue);\n        }\n    };\n}\n","import { Context } from \"../context/Context\";\nimport { TypedArray } from \"../types/TypedArray\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { calculateNumber } from \"./calculateNumber\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./calculateEvaluator\";\nimport { TypedArrayResolution } from \"./TypedArrayResolution\";\n\nexport interface TypedArrayConstructor {\n    new (size: number): TypedArray;\n    BYTES_PER_ELEMENT: number;\n}\n\nexport function calculateTypedArray(value: TypedArrayResolution, ArrayConstructor: TypedArrayConstructor = Float32Array): ValueOf<TypedArray | undefined> {\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        const array = new ArrayConstructor(value.length);\n        const compiledArray = value.map(value => calculateNumber(value, 0));\n        return {\n            valueOf(context?: Context): TypedArray {\n                for (let i = 0; i < compiledArray.length; i++) {\n                    array[i] = compiledArray[i].valueOf(context);\n                }\n                return array;\n            }\n        };    \n    }\n    const formula = value;\n    const evaluator = getFormulaEvaluator(formula);\n    let bufferArray: TypedArray;\n    return {\n        valueOf(context?: Context): TypedArray | undefined {\n            const value = calculateEvaluator<TypedArray | number[] | undefined>(evaluator, context, formula, undefined);\n            if (!value) {\n                return undefined;\n            }\n            if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n                || value instanceof Int16Array || value instanceof Uint16Array\n                || value instanceof Int32Array || value instanceof Uint32Array) {\n                return value;\n            }\n            if (Array.isArray(value)) {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value.length);\n                }\n                bufferArray.set(value);\n                return bufferArray;\n            }\n        \n            if (typeof(value) === \"number\") {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value / ArrayConstructor.BYTES_PER_ELEMENT);\n                }\n                return bufferArray;\n            }\n\n            throw new Error(`Formula ${formula} doesnt't evaluate to a TypedArray.`);\n        }\n    };\n}","import { ActionsAction } from \"../actions/ActionsAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior } from \"./Convertor\";\nimport { Utils } from \"./Convertor\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\n\nexport async function convertActionsProperty<T>(\n        action: ActionsAction<T>,\n        results: ExecutionStep[],\n        utils: Utils<T & ActionsAction<T>>,\n        external: Record<string, any>,\n        actionConvertorMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.actions?.length) {\n        return;\n    }\n    for (let a of action.actions) {\n        await convertAction(a, results, utils, external, actionConvertorMap);\n    }\n}\n","import { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\nimport { LogicAction } from \"../actions/LogicAction\";\n\nexport async function convertConditionProperty<T>(\n        action: LogicAction,\n        results: ExecutionStep[],\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (action.condition === undefined) {\n        return;\n    }\n    if (!action.condition) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { condition, ...subAction } = action;\n    const conditionResolution = calculateBoolean(condition);\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction(subAction, subStepResults, utils, external, actionConversionMap);\n    results.push((context, parameters) => {\n        if (conditionResolution.valueOf(context)) {\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;        \n}\n","import { PauseAction } from \"../actions/PauseAction\";\nimport { Context } from \"../context/Context\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\nimport { calculateNumber } from \"../resolutions/calculateNumber\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\n\nexport async function convertDelayProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.delay) {\n        return;\n    }\n\n    const { delay, ...subAction } = action;\n    const delayAmount = calculateNumber(delay);\n    const postStepResults: ExecutionStep[] = [];\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, actionConversionMap);\n    }\n    const performPostSteps = (context: Context, parameters: ExecutionParameters) => {\n        execute(postStepResults, parameters, context);\n    }\n\n    results.push((context, parameters) => {\n        const timeout = external.setTimeout(performPostSteps, delayAmount.valueOf(context), context, parameters);\n        context.cleanupActions.push(() => clearTimeout(timeout));\n    });\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertPauseProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.pause) {\n        return;\n    }\n\n    const { pause, ...subAction } = action;\n    const pauseResolution = calculateBoolean(pause);\n    const postStepResults: ExecutionStep[] = [];\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, actionConversionMap);\n    }\n\n    const step: ExecutionStep = (context, parameters) => {\n        if (!pauseResolution.valueOf(context)) {\n            context.postActionListener.delete(step);\n            execute(postStepResults, parameters, context);\n        } else if (!context.postActionListener.has(step)) {\n            context.postActionListener.add(step);\n        }\n    };\n\n    results.push(step);\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertLockProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.lock && !action.unlock) {\n        return;\n    }\n\n    const { lock, unlock, ...subAction } = action;\n\n\n    if (unlock) {\n        const unlockResolution = calculateBoolean(unlock);\n        results.push((context) => {\n            if (unlockResolution.valueOf(context)) {\n                context.locked = false;\n            }\n        });\n    }\n\n    if (lock) {\n        const lockResolution = calculateBoolean(lock);\n        const postStepResults: ExecutionStep[] = [];\n        const remainingActions = utils.getRemainingActions();\n        await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n        for (let action of remainingActions) {\n            await convertAction(action, postStepResults, utils, external, actionConversionMap);\n        }\n\n        results.push((context, parameters) => {\n            if (!lockResolution.valueOf(context)) {\n                execute(postStepResults, parameters, context);\n            } else {\n                context.locked = true;\n                const step: ExecutionStep = (context, parameters) => {\n                    if (!context.locked) {\n                        context.postActionListener.delete(step);\n                        execute(postStepResults, parameters, context);    \n                    }\n                };\n                context.postActionListener.add(step);\n            }\n        });\n        return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n    }\n}","import { ReferenceAction } from \"../actions/ReferenceAction\";\nimport { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { calculateString } from \"../resolutions/calculateString\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { DEFAULT_EXTERNALS } from \"./default-externals\";\n\nasync function fetchAction<T>(\n        path: string,\n        results: ExecutionStep[],\n        utils: Utils<T & ReferenceAction>,\n        external: Record<string, any> | typeof DEFAULT_EXTERNALS,\n        actionConversionMap: ActionConvertorList): Promise<void> {\n    const response = await external.fetch(path);\n    const json = await response.json();\n    await convertAction(json, results, utils, external, actionConversionMap);    \n}\n\nexport async function convertReferenceProperty<T>(\n        action: ReferenceAction,\n        results: ExecutionStep[],\n        utils: Utils<T & ReferenceAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior|void> {\n    if (action.reference === undefined) {\n        return;\n    }\n\n    const { reference, ...subAction } = action;\n    if (Object.keys(subAction).length) {\n        console.warn(\"Remaining properties on reference are ignored:\", subAction);\n    }\n\n    if (typeof(reference) === \"string\") {\n        await fetchAction<T>(reference, results, utils, external, actionConversionMap);\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    } else {\n        const postStepResults: ExecutionStep[] = [];\n        const remainingActions = utils.getRemainingActions();\n        for (let action of remainingActions) {\n            convertAction(action, postStepResults, utils, external, actionConversionMap);\n        }\n\n        const fetchedResults: ExecutionStep[] = [];\n        const path = calculateString(reference);\n        results.push((context, parameters) => {\n            fetchAction(path.valueOf(context), fetchedResults, utils, external, actionConversionMap)\n                .then(() => {\n                    execute(fetchedResults, parameters, context);\n                    execute(postStepResults, parameters, context);    \n                });\n        });\n        return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n    }\n}\n","import { LogAction } from \"../actions/LogAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { Resolution } from \"../resolutions/Resolution\";\nimport { calculateResolution } from \"../resolutions/calculate\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ActionConvertorList } from \"./convert-action\";\n\nexport async function convertLogProperty<T>(\n        action: LogAction,\n        results: ExecutionStep[],\n        _: Utils<T>,\n        external: Record<string, any>,\n        __: ActionConvertorList): Promise<ConvertBehavior|void> {\n    if (action.log === undefined) {\n        return;\n    }\n    const messages: Resolution[] = Array.isArray(action.log) ? action.log : [action.log];\n    const resolutions = messages.map(m => calculateResolution(m));\n    results.push((context)=> external.log(...resolutions.map(r => r?.valueOf(context))));    \n}\n","import { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { calculateNumber } from \"../resolutions/calculateNumber\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { LogicAction } from \"../actions/LogicAction\";\n\nexport async function convertLoopProperty<T>(\n        action: T & LogicAction,\n        stepResults: ExecutionStep[],\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (action.loop === undefined) {\n        return;\n    }\n    if (!action.loop) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { loop, ...subAction } = action;\n    const loopResolution = calculateNumber(loop, 0);\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, actionConversionMap);\n    stepResults.push((context, parameters) => {\n        const numLoops = loopResolution.valueOf(context);\n        for (let i = 0; i < numLoops; i++) {\n            parameters.index = i;\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ConvertBehavior, Utils } from \"./Convertor\";\nimport { Resolution } from \"../resolutions/Resolution\";\nimport { calculateResolution } from \"../resolutions/calculate\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\nimport { ScriptAction } from \"../actions/ScriptAction\";\nimport { Context } from \"../context/Context\";\nimport { StringResolution } from \"../resolutions/StringResolution\";\nimport { calculateString } from \"../resolutions/calculateString\";\nimport { HookAction } from \"../actions/HookAction\";\n\nfunction newParams(context: Context): ExecutionParameters {\n    return context.objectPool?.pop() ?? {};\n}\n\nfunction recycleParams(context: Context, params: ExecutionParameters): void {\n    for (let k in params) {\n        delete params[k];\n    }\n    context.objectPool?.push(params);\n}\n\nexport async function convertParametersProperty<T>(\n        action: ScriptAction,\n        results: ExecutionStep[],\n        utils: Utils<T & ScriptAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.parameters) {\n        return;\n    }\n    const { parameters, ...subAction } = action;\n\n    const paramResolutions: Record<string, Resolution> = parameters;\n    const paramEntries: [string, ValueOf<SupportedTypes> | undefined][] = Object.entries(paramResolutions)\n        .map(([key, resolution]) => [key, calculateResolution(resolution)]);\n\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction(subAction, subStepResults, utils, external, actionConversionMap);\n\n    results.push((context, parameters) => {\n        const paramValues: ExecutionParameters = newParams(context);\n        for (let k in parameters) {\n            paramValues[k] = parameters[k];\n        }\n        for (let entry of paramEntries) {\n            const key: string = entry[0];\n            paramValues[key] = entry[1]?.valueOf(context);\n        }\n\n        execute(subStepResults, paramValues, context);\n\n        recycleParams(context, paramValues);\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\nexport async function convertHooksProperty<T>(\n        action: HookAction & T,\n        results: ExecutionStep[],\n        utils: Utils<T & HookAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior|void> {\n    if (!action.hooks) {\n        return;\n    }\n    const { hooks, ...subAction } = action;\n\n    const hooksResolution: StringResolution[] = hooks;\n    const hooksValueOf: ValueOf<string>[] = hooksResolution.map(hook => calculateString(hook));\n\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction(subAction, subStepResults, utils, external, actionConversionMap);\n\n    results.push((context, parameters) => {\n        const paramValues: ExecutionParameters = newParams(context);\n        for (let k in parameters) {\n            paramValues[k] = parameters[k];\n        }\n        for (let hook of hooksValueOf) {\n            const h = hook.valueOf(context);\n            const x = external[h];\n            if (x) {\n                paramValues[h] = x;\n            }\n        }\n\n        execute(subStepResults, paramValues, context);\n\n        recycleParams(context, paramValues);\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ScriptAction } from \"../actions/ScriptAction\";\nimport { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ActionConvertorList } from \"./convert-action\";\n\nexport async function convertScriptProperty<T>(\n        action: ScriptAction,\n        results: ExecutionStep[],\n        {getSteps}: Utils<T>,\n        _: Record<string, any>,\n        __: ActionConvertorList): Promise<ConvertBehavior|void> {\n    if (!action.script || action.scriptTags?.length) {\n        return;\n    }\n    const steps = getSteps({ name: action.script, tags: action.scriptTags });\n    results.push((context, parameters) => execute(steps, parameters, context));\n}\n\n","import { convertActionsProperty } from \"./actions-convertor\";\nimport { convertConditionProperty } from \"./condition-convertor\";\nimport { ActionConvertorList } from \"./convert-action\";\nimport { convertDelayProperty, convertLockProperty, convertPauseProperty } from \"./convert-pause\";\nimport { convertReferenceProperty } from \"./convert-reference\";\nimport { convertLogProperty } from \"./log-convertor\";\nimport { convertLoopProperty } from \"./loop-convertor\";\nimport { convertHooksProperty, convertParametersProperty } from \"./parameters-convertor\";\nimport { convertScriptProperty } from \"./script-convertor\";\n\nexport function getDefaultConvertors(): ActionConvertorList {\n    return [\n        convertHooksProperty,\n        convertParametersProperty,\n        convertReferenceProperty,\n        convertLoopProperty,\n        convertConditionProperty,\n        convertDelayProperty,\n        convertPauseProperty,\n        convertLockProperty,\n        convertLogProperty,\n        convertScriptProperty,\n        convertActionsProperty,\n    ];\n}\n","import { Context, createContext } from \"../context/Context\";\nimport { ActionConvertorList, convertScripts } from \"../convertor/convert-action\";\nimport { getDefaultConvertors } from \"../convertor/default-convertors\";\nimport { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { Script, ScriptFilter, Tag, filterScripts } from \"../scripts/Script\";\n\nexport interface LoopBehavior {\n    cleanupAfterLoop?: boolean;\n}\n\nexport class ScriptProcessor<T, E = {}> {\n    private scripts: Script<T>[];\n    private scriptMap?: Map<Script<T>, ExecutionStep[]>;\n    private external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    private actionConversionMap: ActionConvertorList;\n\n    constructor(scripts: Script<T>[], external = {}, actionConversionMap: ActionConvertorList = getDefaultConvertors()) {\n        this.scripts = scripts;\n        this.actionConversionMap = actionConversionMap;\n        this.external = {...DEFAULT_EXTERNALS, ...external};\n    }\n\n    private async fetchScripts(): Promise<Map<Script<T>, ExecutionStep[]>> {\n        if (!this.scriptMap) {\n            this.scriptMap = await convertScripts(this.scripts, this.external, this.actionConversionMap);\n        }\n        return this.scriptMap!;\n    }\n\n    private createLoopCleanup(behavior: LoopBehavior, context: Context) {\n        const cleanupActions = context.cleanupActions;\n        return behavior.cleanupAfterLoop && cleanupActions ? () => {\n            for (let cleanup of cleanupActions) {\n                cleanup();\n            }\n            cleanupActions.length = 0;\n        } : () => {};\n    }\n\n    async getSteps(filter: ScriptFilter) {\n        const scriptMap = await this.fetchScripts();\n        const scripts = filterScripts(this.scripts, filter);\n        const steps: ExecutionStep[] = [];\n        scripts.forEach(script => scriptMap.get(script)?.forEach(step => steps.push(step)));\n        return steps;\n    }\n\n    async runByName(name: string) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ name }), undefined, context);\n        return () => context.cleanupActions?.forEach(action => action());\n    }\n\n    async runByTags(tags: Tag[]) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ tags }), undefined, context);\n        return () => context.cleanupActions?.forEach(action => action());\n    }\n\n    private async loopWithFilter(filter: ScriptFilter, behavior: LoopBehavior = {}) {\n        const context: Context = createContext();\n        const parameters: ExecutionParameters = { time: 0 };\n        const steps = await this.getSteps(filter);\n        const loopCleanup = this.createLoopCleanup(behavior, context);\n        const loop = (time: number) => {\n            parameters.time = time;\n            execute(steps, parameters, context);\n            loopCleanup();\n            animationFrameId = requestAnimationFrame(loop);\n        };\n        let animationFrameId = requestAnimationFrame(loop);\n        return () => {\n            loopCleanup();\n            cancelAnimationFrame(animationFrameId);\n        }\n    }\n    \n    async loopByName(name: string, behavior: LoopBehavior = {}) {\n        return await this.loopWithFilter({ name }, behavior);\n    }\n\n    async loopByTags(tags: string[], behavior: LoopBehavior = {}) {\n        return await this.loopWithFilter({ tags }, behavior);\n    }\n}"],"names":["DEFAULT_EXTERNALS","log","console","setTimeout","clearTimeout","fetch","global","createContext","_temp","_ref$parameters","_ref","parameters","_ref$cleanupActions","cleanupActions","_ref$objectPool","objectPool","_ref$postActionListen","postActionListener","Set","_ref$external","external","_extends","locked","ConvertBehavior","execute","steps","context","length","params","changedParameters","push","_iterator","_createForOfIteratorHelperLoose","_step","done","step","value","forEach","listener","pop","filterMatchesTags","filter","tags","_filter$tags","every","tag","some","t","Array","isArray","filterScripts","scripts","namesToFilter","name","undefined","indexOf","executeScript","scriptName","actionConversionMap","Promise","resolve","convertScripts","then","scriptMap","script","find","get","action","e","reject","Map","getSteps","filteredScripts","_scriptMap$get","apply","_temp2","_forOf","_scriptMap$get2","_interrupt","has","set","scriptSteps","actions","_forTo","i","getRemainingActions","slice","convertAction","convertBehavior","SKIP_REMAINING_ACTIONS","stepResults","utils","convertor","SKIP_REMAINING_CONVERTORS","_exit","executeAction","results","hasFormula","resolution","isFormula","item","Object","values","formula","charAt","calculateEvaluator","evaluator","defaultValue","scope","_context$parameters","_evaluator$evaluate","evaluate","error","getFormulaEvaluator","Error","mathEvaluator","math","substring","compile","calculateArray","array","valueOf","map","calculateResolution","evalItem","calculateMap","evaluatorEntries","entries","key","fromEntries","_ref2","Float32Array","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","calculateNumber","calculateString","calculateBoolean","calculateTypedArray","ArrayConstructor","compiledArray","bufferArray","BYTES_PER_ELEMENT","convertActionsProperty","actionConvertorMap","_action$actions","a","convertConditionProperty","condition","subAction","_objectWithoutPropertiesLoose","_excluded","conditionResolution","subStepResults","convertLockProperty","lock","unlock","_excluded3","unlockResolution","lockResolution","postStepResults","remainingActions","_temp6","add","_temp5","convertPauseProperty","pause","_excluded2","pauseResolution","_temp4","_temp3","convertDelayProperty","delay","delayAmount","performPostSteps","timeout","convertReferenceProperty","reference","keys","warn","fetchAction","fetchedResults","path","response","json","convertLogProperty","_","__","messages","resolutions","m","r","convertLoopProperty","loop","loopResolution","numLoops","index","convertHooksProperty","hooks","hooksResolution","hooksValueOf","hook","paramValues","newParams","k","_iterator2","_step2","h","x","recycleParams","_context$objectPool$p","_context$objectPool","_context$objectPool2","convertParametersProperty","paramResolutions","paramEntries","_entry$","entry","convertScriptProperty","_action$scriptTags","scriptTags","getDefaultConvertors","ScriptProcessor","_proto","prototype","fetchScripts","_this","_convertScripts","createLoopCleanup","behavior","cleanupAfterLoop","cleanup","_this2","runByName","_this3","_this3$getSteps","_context$cleanupActio","runByTags","_this4","_this4$getSteps","_context$cleanupActio2","loopWithFilter","time","_this5","loopCleanup","animationFrameId","requestAnimationFrame","cancelAnimationFrame","loopByName","_this6","loopByTags","_this7"],"mappings":"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"}