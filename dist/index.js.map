{"version":3,"file":"index.js","sources":["../src/core/convertor/default-externals.ts","../src/core/context/Context.ts","../src/core/convertor/Convertor.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/core/execution/ExecutionStep.ts","../src/core/scripts/Script.ts","../src/core/convertor/convert-action.ts","../src/core/convertor/parameter-utils.ts","../src/core/resolutions/formula/Formula.ts","../src/core/resolutions/formula/formula-utils.ts","../src/core/resolutions/formula/formula-evaluator.ts","../src/core/resolutions/calculateArray.ts","../src/core/resolutions/calculateMap.ts","../src/core/resolutions/calculate.ts","../src/core/resolutions/calculateNumber.ts","../src/core/resolutions/calculateString.ts","../src/core/resolutions/calculateBoolean.ts","../src/core/resolutions/calculateTypeArray.ts","../src/core/convertor/actions-convertor.ts","../src/core/convertor/condition-convertor.ts","../src/core/convertor/convert-pause.ts","../src/core/convertor/convert-set.ts","../src/core/convertor/hooks-convertor.ts","../src/core/convertor/log-convertor.ts","../src/core/convertor/loop-convertor.ts","../src/core/convertor/parameters-convertor.ts","../src/core/convertor/refresh-convertor.ts","../src/core/convertor/script-convertor.ts","../src/core/convertor/default-convertors.ts","../src/core/processor/ScriptProcessor.ts"],"sourcesContent":["export const DEFAULT_EXTERNALS = {\n    log: console.log,\n    setTimeout,\n    clearTimeout,\n    fetch: global.fetch,\n};\n","import { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { ExecutionParameters, ExecutionStep } from \"../execution/ExecutionStep\";\n\nexport interface ExecutionWithParams {\n    steps: ExecutionStep[];\n    parameters: ExecutionParameters;\n}\n\nexport interface Context<E = {}> {\n    parameters: ExecutionParameters[];\n    cleanupActions:(() => void)[];\n    objectPool: ExecutionParameters[];\n    postActionListener: Set<ExecutionWithParams>;\n    external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    locked: boolean;\n}\n\nexport function createContext<E>({\n        parameters = [],\n        cleanupActions = [],\n        objectPool = [],\n        postActionListener = new Set(),\n        external = {},\n}: {\n    parameters?: ExecutionParameters[];\n    cleanupActions?:(() => void)[];\n    objectPool?: ExecutionParameters[];\n    postActionListener?: Set<ExecutionWithParams>;\n    external?: E | {};\n} = {}): Context<E|{}> {\n    return {\n        parameters,\n        cleanupActions,\n        objectPool,\n        postActionListener,\n        external: {...DEFAULT_EXTERNALS, ...external},\n        locked: false,\n    };\n}","import { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { RefreshBehavior } from \"../processor/ScriptProcessor\";\nimport { ScriptFilter } from \"../scripts/Script\";\nimport { ActionConvertorList } from \"./convert-action\";\n\nexport type GetSteps = (filter: ScriptFilter) => ExecutionStep[];\n\nexport enum ConvertBehavior {\n    NONE,\n    SKIP_REMAINING_CONVERTORS,\n    SKIP_REMAINING_ACTIONS,\n}\n\nexport interface Utils<T> {\n    refreshSteps(steps: ExecutionStep[], loopBehavior?: RefreshBehavior, processId?: string): () => void;\n    stopRefresh(processId?: string): void;\n    getSteps: GetSteps;\n    getRemainingActions: () => T[];\n}\n\nexport type Convertor<T> = (action: T, results: ExecutionStep[], utils: Utils<T>, external: Record<string, any>, actionConversionMap: ActionConvertorList) => Promise<ConvertBehavior | void>;\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Context, createContext } from \"../context/Context\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\n\nexport type ExecutionParameters = Record<string, SupportedTypes>;\nexport type ExecutionStep = (parameters: ExecutionParameters, context: Context) => void;\n\nexport function execute(steps?: ExecutionStep[], parameters: ExecutionParameters = {}, context: Context = createContext()) {\n    if (!steps?.length) {\n        return;\n    }\n    if (!context.parameters) {\n        context.parameters = [];\n    }\n\n    const params = context.parameters;\n    const changedParameters = params[params.length-1] !== parameters;\n    if (changedParameters) {\n        params.push(parameters);\n    }\n    for (let step of steps) {\n        step(parameters, context);\n    }\n    context.postActionListener.forEach(listener => {\n        for (let i in parameters) {\n            listener.parameters[i] = parameters[i];\n        }\n        listener.steps.forEach(step => step(listener.parameters, context));\n    });\n\n    if (changedParameters) {\n        params.pop();\n    }\n}\n","import { DokAction } from \"../actions/Action\";\n\nexport type Tag = string|[string, string|number|boolean];\n\nexport interface Script<T> {\n    name?: string;\n    actions: (T & DokAction<T>)[];\n    tags?: Tag[];\n}\n\nexport interface ScriptFilter {\n    name?: string | string[];\n    tags?: Tag[];\n}\n\nfunction filterMatchesTags(filter: ScriptFilter, tags?: Tag[]) {\n    return filter.tags?.every(tag => {\n        if (typeof(tag) === \"string\") {\n            return tags?.some((t) => t === tag || (Array.isArray(t) && t[0] === tag));\n        } else {\n            return tags?.some((t) => Array.isArray(t) && t[0] === tag[0] && t[1] === tag[1]);\n        }\n    });\n}\n\nexport function filterScripts<T>(scripts: Script<T>[], filter: ScriptFilter): Script<T>[] {\n    const namesToFilter = !filter.name ? undefined : Array.isArray(filter.name) ? filter.name : [filter.name];\n    return scripts.filter(({name, tags}) => {\n        if (namesToFilter?.length && namesToFilter.indexOf(name ?? \"\") < 0) {\n            return false;\n        }    \n        if (filter.tags && !filterMatchesTags(filter, tags)) {\n            return false;\n        }\n        return true;\n    });\n}\n","import { Context, createContext } from \"../context/Context\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ScriptProcessorHelper } from \"../processor/ScriptProcessor\";\nimport { Script, ScriptFilter, filterScripts } from \"../scripts/Script\";\nimport { ConvertBehavior, Convertor, Utils } from \"./Convertor\";\n\nexport type ActionConvertorList = Convertor<any>[];\n\nexport async function convertAction<T>(\n        action: T,\n        stepResults: ExecutionStep[],\n        utils: Utils<T>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    for (let convertor of actionConversionMap) {\n        const convertBehavior = await convertor(action, stepResults, utils, external, actionConversionMap);\n        if (convertBehavior === ConvertBehavior.SKIP_REMAINING_CONVERTORS) {\n            return;\n        } else if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n            return convertBehavior;\n        }\n    }\n    return;    \n}\n\nexport async function convertScripts<T>(\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList,\n        processorHelper: ScriptProcessorHelper): Promise<Map<Script<T>, ExecutionStep[]>> {\n    const scriptMap: Map<Script<T>, ExecutionStep[]> = new Map();\n    scripts.forEach(script => scriptMap.set(script, []));\n    const getSteps = (filter: ScriptFilter) => {\n        const filteredScripts = filterScripts(scripts, filter);\n        const steps: ExecutionStep[] = [];\n        filteredScripts.forEach(script => steps.push(...(scriptMap.get(script)!)));\n        return steps;\n    };\n    for (let script of scripts) {\n        const scriptSteps = scriptMap.get(script) ?? [];\n        const { actions } = script;\n        for (let i = 0; i < actions.length; i++) {\n            const getRemainingActions = () => actions.slice(i + 1);\n            const convertBehavior = await convertAction(actions[i], scriptSteps, {\n                getSteps, getRemainingActions, refreshSteps: processorHelper.refreshSteps, stopRefresh: processorHelper.stopRefresh,\n            }, external, actionConversionMap);\n            if (convertBehavior === ConvertBehavior.SKIP_REMAINING_ACTIONS) {\n                break;\n            }\n        }\n    }\n    return scriptMap;\n}\n\nexport async function executeScript<T>(\n        scriptName: string,\n        parameters: ExecutionParameters = {},\n        scripts: Script<T>[],\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList,\n        processorHelper: ScriptProcessorHelper): Promise<() => void> {\n    const context: Context = createContext();\n    const scriptMap = await convertScripts(scripts, external, actionConversionMap, processorHelper);\n    const script = scripts.find(({name}) => name === scriptName);\n    const steps = script ? scriptMap.get(script) : [];\n    execute(steps, parameters, context);\n    return () => {\n        context.cleanupActions!.forEach(action => action());\n        context.cleanupActions!.length = 0;\n    };\n}\n\nexport async function executeAction<T>(\n        action: T,\n        parameters: ExecutionParameters,\n        context: Context,\n        utils: Utils<T>,\n        actionConversionMap: ActionConvertorList): Promise<void> {\n    const results: ExecutionStep[] = [];\n    if (ConvertBehavior.SKIP_REMAINING_ACTIONS !== await convertAction(action, results, utils, context.external, actionConversionMap)) {\n        execute(results, parameters, context);\n    }\n}","import { Context } from \"../context/Context\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function newParams(parameters: ExecutionParameters | undefined, context: Context): ExecutionParameters {\n    const params = context.objectPool?.pop() ?? {};\n    if (parameters) {\n        for (let k in parameters) {\n            params[k] = parameters[k];\n        }    \n    }\n    return params;\n}\n\nexport function recycleParams(params: ExecutionParameters, context: Context): void {\n    for (let k in params) {\n        delete params[k];\n    }\n    context.objectPool?.push(params);\n}\n\n","export const FORMULA_SEPERATORS = [\"~\", \"{\", \"}\"];   //  formula separator\n\nexport type Formula = string\n\nexport type Expression = {\n    formula: Formula;\n}\n\n","import { Resolution } from \"../Resolution\";\nimport { Expression, FORMULA_SEPERATORS, Formula } from \"./Formula\";\n\nexport function hasFormula(resolution: Resolution): boolean {\n    if (isFormula(resolution)) {\n        return true;\n    }\n    if (Array.isArray(resolution)) {\n        return resolution.some(item => hasFormula(item));\n    }\n    if (resolution && typeof (resolution) === \"object\") {\n        return hasFormula(Object.values(resolution)) || hasFormula(Object.keys(resolution));\n    }\n    return false;\n}\n\nexport function isFormula(value: Formula | Expression | any) {\n    if (!value) {\n        return false;\n    }\n    if (typeof(value) !== \"string\" && typeof(value) !== \"object\") {\n        return false;\n    }\n    const formula = typeof(value) === \"string\" ? value : value.formula;\n    const [startCharacter, prefix, suffix] = FORMULA_SEPERATORS.map(char => formula?.indexOf(char));\n    return startCharacter === 0 && prefix > startCharacter && suffix > prefix;\n}\n\ninterface FormulaChunk {\n    formula: Formula;\n    textSuffix: string;\n}\n\nexport function getInnerFormulas(value: Formula | Expression | any): FormulaChunk[] {\n    const formula: string = typeof(value) === \"string\" ? value : value.formula;\n    const [startCharacter, prefix, suffix] = FORMULA_SEPERATORS;\n\n    //  parse formulas out. Formulas have format like this: ~{formula}text{formula}.\n    return formula.substring(startCharacter.length).split(prefix).map((chunk, index) => {\n        if (index === 0) {\n            return { textSuffix: chunk, formula: \"\" };\n        }\n        const [formula, textSuffix] = chunk.split(suffix);\n        return { formula, textSuffix };\n    }).filter(({ textSuffix, formula}) => textSuffix.length || formula.length);\n}\n\nconst IDENTIFIER_REGEX = /^([^\\x00-\\x7F]|[A-Za-z_])([^\\x00-\\x7F]|\\w)+$/;\n\nexport function isSimpleInnerFormula(innerFormula: string) {\n    return IDENTIFIER_REGEX.test(innerFormula);\n}\n\n","import * as math from \"mathjs\";\nimport { Expression, FORMULA_SEPERATORS, Formula } from \"./Formula\";\nimport { getInnerFormulas, isFormula, isSimpleInnerFormula } from \"./formula-utils\";\nimport { ExecutionParameters } from \"../../execution/ExecutionStep\";\n\nexport function calculateEvaluator<T>(evaluator: math.EvalFunction, parameters: ExecutionParameters = {}, formula: Formula | Expression, defaultValue: T): T {\n    const scope = parameters;\n    try {\n        return evaluator.evaluate(scope ?? {}) ?? defaultValue;\n    } catch (e) {\n        console.error(\"Error: \" + e + \" on formula: \" + formula + \", scope: \", JSON.parse(JSON.stringify(scope)));\n    }\n    return defaultValue;\n}\n\nfunction getEvaluator(formula: string): math.EvalFunction {\n    if (!formula.length) {\n        return {\n            evaluate: () => \"\",\n        };\n    }\n    const mathEvaluator = math.parse(formula).compile();\n    if (isSimpleInnerFormula(formula)) {\n        return {\n            evaluate(scope?: any) {\n                return scope[formula] ?? mathEvaluator.evaluate(scope);\n            },\n        };\n    }\n    return mathEvaluator;    \n}\n\nexport function getFormulaEvaluator(value: Formula | Expression): math.EvalFunction {\n    if (!isFormula(value)) {\n        throw new Error(`Formula: ${value} must match the format: \"${FORMULA_SEPERATORS[0]}formula${FORMULA_SEPERATORS[1]}\".`);\n    }\n    const values = getInnerFormulas(value);\n    if (values.length === 1 && !values[0].textSuffix.length) {\n        return getEvaluator(values[0].formula);\n    } else {\n        const evaluators = values.map(({ formula, textSuffix }) => {\n            return { mathEvaluator: getEvaluator(formula), textSuffix};\n        });\n\n        return {\n            evaluate(scope?: any) {\n                return evaluators.map(({ mathEvaluator, textSuffix }) => {\n                    return mathEvaluator.evaluate(scope) + textSuffix;\n                }).join(\"\");\n            },\n        };\n    }\n}\n\n","import { ValueOf } from \"../types/ValueOf\";\nimport { ArrayResolution } from \"./ArrayResolution\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { Expression, Formula } from \"./formula/Formula\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { hasFormula, isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateArray(value: ArrayResolution): ValueOf<SupportedTypes> | undefined {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        if (!Array.isArray(value)) {\n            throw new Error(\"value is not an array\");\n        }\n        const array = value as SupportedTypes[];\n        return { valueOf: () => array };\n    }\n    if (!value) {\n        return undefined;\n    }\n    if (isFormula(value)) {\n        const formula = value as (Formula|Expression);\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(parameters: ExecutionParameters): SupportedTypes[] | undefined {\n                return calculateEvaluator<SupportedTypes[] | undefined>(evaluator, parameters, formula, undefined);\n            }\n        };\n    }\n    const array = value as Resolution[]\n\n    const evaluator = array.map(resolution => calculateResolution(resolution));\n\n    return {\n        valueOf(parameters: ExecutionParameters): SupportedTypes {\n            const value = evaluator.map(evalItem => evalItem?.valueOf(parameters));\n            return value;\n        }\n    };\n}","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateResolution } from \"./calculate\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { Expression, Formula } from \"./formula/Formula\";\nimport { MapResolution } from \"./MapResolution\";\nimport { Resolution } from \"./Resolution\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { hasFormula, isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateMap(value: MapResolution): ValueOf<{ [key:string]:SupportedTypes } | undefined> {\n    //  check if we have any resolution to perform\n    if (!hasFormula(value)) {\n        const map = value as {[key: string]:SupportedTypes}\n        return { valueOf: () => map };\n    }\n    if (isFormula(value)) {\n        const formula = value as (Formula|Expression);\n        const evaluator = getFormulaEvaluator(formula);\n        return {\n            valueOf(parameters: ExecutionParameters): { [key:string]:SupportedTypes } | undefined {\n                return calculateEvaluator<{ [key:string]:SupportedTypes } | undefined>(evaluator, parameters, formula, undefined);\n            }\n        };\n    }\n    const map = value as {[key: string]:Resolution}\n    const evaluatorEntries = Object.entries(map).map(([key, resolution]) => [key, calculateResolution(resolution)]);\n\n    return {\n        valueOf(parameters: ExecutionParameters): { [key:string]:SupportedTypes } | undefined {\n            return Object.fromEntries(evaluatorEntries.map(([key, evalItem]) => [key, evalItem?.valueOf(parameters)]));\n        }\n    };\n}","import { ValueOf } from \"../types/ValueOf\";\nimport { Resolution } from \"./Resolution\";\nimport { calculateArray } from \"./calculateArray\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { SupportedTypes } from \"./SupportedTypes\";\nimport { calculateMap } from \"./calculateMap\";\nimport { isFormula } from \"./formula/formula-utils\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateResolution(value: Resolution): ValueOf<SupportedTypes> | undefined | null {\n    if (!value) {\n        return {\n            valueOf() {\n                return value;\n            }\n        };\n    }\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n    if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return value;\n    }\n    if (typeof(value) === \"string\" && !isFormula(value)) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return calculateArray(value);\n    }\n    if (typeof(value) === \"object\") {\n        return calculateMap(value);\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters = {}): SupportedTypes {\n            return calculateEvaluator<SupportedTypes>(evaluator, parameters, value, undefined);\n        }\n    };\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\n\nexport function calculateNumber<T extends number = number>(value: NumberResolution<T>, defaultValue:T|0 = 0): ValueOf<T|0>|number {\n    if (typeof(value) === \"number\") {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters?: ExecutionParameters): T|0 {\n            return calculateEvaluator<T|0>(evaluator, parameters, value, defaultValue);\n        }\n    };\n}\n","import { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { StringResolution } from \"./StringResolution\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { isFormula } from \"./formula/formula-utils\";\n\nexport function calculateString<T extends string = string>(value: StringResolution<T>, defaultValue: T|\"\" = \"\"): ValueOf<T|\"\">|string {\n    if (typeof(value) === \"string\" && !isFormula(value)) {\n        return value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters): T|\"\" {\n            return calculateEvaluator<T|\"\">(evaluator, parameters, value, defaultValue);\n        }\n    };\n\n}\n","import { ValueOf } from \"../types/ValueOf\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { NumberResolution } from \"./NumberResolution\";\nimport { BooleanResolution } from \"./BooleanResolution\";\nimport { ExecutionParameters } from \"../execution/ExecutionStep\";\n\nexport function calculateBoolean(value: BooleanResolution | NumberResolution, defaultValue = false): ValueOf<boolean> {\n    if (typeof(value) === \"boolean\" || typeof(value) === \"number\") {\n        return !!value;\n    }\n    if (value === undefined) {\n        return {\n            valueOf() {\n                return defaultValue;\n            }\n        };\n    }\n    const evaluator = getFormulaEvaluator(value);\n    return {\n        valueOf(parameters: ExecutionParameters): boolean {\n            return !!calculateEvaluator<boolean | number>(evaluator, parameters, value, defaultValue);\n        }\n    };\n}\n","import { ExecutionParameters } from \"../execution/ExecutionStep\";\nimport { TypedArray } from \"../types/TypedArray\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { calculateNumber } from \"./calculateNumber\";\nimport { calculateEvaluator, getFormulaEvaluator } from \"./formula/formula-evaluator\";\nimport { TypedArrayResolution } from \"./TypedArrayResolution\";\n\nexport interface TypedArrayConstructor {\n    new (size: number): TypedArray;\n    BYTES_PER_ELEMENT: number;\n}\n\nexport function calculateTypedArray(value: TypedArrayResolution, ArrayConstructor: TypedArrayConstructor = Float32Array): ValueOf<TypedArray | undefined> {\n    if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n        || value instanceof Int16Array || value instanceof Uint16Array\n        || value instanceof Int32Array || value instanceof Uint32Array) {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        const array = new ArrayConstructor(value.length);\n        const compiledArray = value.map(value => calculateNumber(value, 0));\n        return {\n            valueOf(parameters: ExecutionParameters): TypedArray {\n                for (let i = 0; i < compiledArray.length; i++) {\n                    array[i] = compiledArray[i].valueOf(parameters);\n                }\n                return array;\n            }\n        };    \n    }\n    const formula = value;\n    const evaluator = getFormulaEvaluator(formula);\n    let bufferArray: TypedArray;\n    return {\n        valueOf(parameters: ExecutionParameters): TypedArray | undefined {\n            const value = calculateEvaluator<TypedArray | number[] | undefined>(evaluator, parameters, formula, undefined);\n            if (!value) {\n                return undefined;\n            }\n            if (value instanceof Float32Array || value instanceof Int8Array || value instanceof Uint8Array\n                || value instanceof Int16Array || value instanceof Uint16Array\n                || value instanceof Int32Array || value instanceof Uint32Array) {\n                return value;\n            }\n            if (Array.isArray(value)) {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value.length);\n                }\n                bufferArray.set(value);\n                return bufferArray;\n            }\n        \n            if (typeof(value) === \"number\") {\n                if (!bufferArray) {\n                    bufferArray = new ArrayConstructor(value / ArrayConstructor.BYTES_PER_ELEMENT);\n                }\n                return bufferArray;\n            }\n\n            throw new Error(`Formula ${formula} doesnt't evaluate to a TypedArray.`);\n        }\n    };\n}","import { ActionsAction } from \"../actions/ActionsAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior } from \"./Convertor\";\nimport { Utils } from \"./Convertor\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\n\nexport async function convertActionsProperty<T>(\n        action: ActionsAction<T>,\n        results: ExecutionStep[],\n        utils: Utils<T & ActionsAction<T>>,\n        external: Record<string, any>,\n        actionConvertorMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.actions?.length) {\n        return;\n    }\n    for (let a of action.actions) {\n        await convertAction(a, results, utils, external, actionConvertorMap);\n    }\n}\n","import { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\nimport { LogicAction } from \"../actions/LogicAction\";\n\nexport async function convertConditionProperty<T>(\n        action: LogicAction,\n        results: ExecutionStep[],\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (action.condition === undefined) {\n        return;\n    }\n    if (!action.condition) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { condition, ...subAction } = action;\n    const conditionResolution = calculateBoolean(condition);\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction(subAction, subStepResults, utils, external, actionConversionMap);\n    results.push((parameters, context) => {\n        if (conditionResolution.valueOf(parameters)) {\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;        \n}\n","import { PauseAction } from \"../actions/PauseAction\";\nimport { Context, ExecutionWithParams } from \"../context/Context\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\nimport { calculateNumber } from \"../resolutions/calculateNumber\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\n\nexport async function convertDelayProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.delay) {\n        return;\n    }\n\n    const { delay, ...subAction } = action;\n    const delayAmount = calculateNumber(delay);\n    const postStepResults: ExecutionStep[] = [];\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, actionConversionMap);\n    }\n    const performPostSteps = (context: Context, parameters: ExecutionParameters) => {\n        execute(postStepResults, parameters, context);\n    }\n\n    results.push((parameters, context) => {\n        const timeout = external.setTimeout(performPostSteps, delayAmount.valueOf(parameters), context, parameters);\n        context.cleanupActions.push(() => clearTimeout(timeout));\n    });\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertPauseProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.pause) {\n        return;\n    }\n\n    const { pause, ...subAction } = action;\n    const pauseResolution = calculateBoolean(pause);\n    const postStepResults: ExecutionStep[] = [];\n    const remainingActions = utils.getRemainingActions();\n    await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n    for (let action of remainingActions) {\n        await convertAction(action, postStepResults, utils, external, actionConversionMap);\n    }\n\n    const step: ExecutionStep = (parameters, context) => {\n        for (let i in parameters) {\n            postExecution.parameters[i] = parameters[i];\n        }\n        if (!pauseResolution.valueOf(postExecution.parameters)) {\n            context.postActionListener.delete(postExecution);\n            execute(postStepResults, postExecution.parameters, context);\n        } else if (!context.postActionListener.has(postExecution)) {\n            context.postActionListener.add(postExecution);\n        }\n    };\n\n    const postExecution: ExecutionWithParams = {\n        steps: [step],\n        parameters: {},\n    };\n\n    results.push(step);\n    return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n}\n\nexport async function convertLockProperty<T>(\n        action: PauseAction,\n        results: ExecutionStep[],\n        utils: Utils<T & PauseAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.lock && !action.unlock) {\n        return;\n    }\n\n    const { lock, unlock, ...subAction } = action;\n\n\n    if (unlock) {\n        const unlockResolution = calculateBoolean(unlock);\n        results.push((parameters, context) => {\n            if (unlockResolution.valueOf(parameters)) {\n                context.locked = false;\n            }\n        });\n    }\n\n    if (lock) {\n        const lockResolution = calculateBoolean(lock);\n        const postStepResults: ExecutionStep[] = [];\n        const remainingActions = utils.getRemainingActions();\n        await convertAction(subAction, postStepResults, utils, external, actionConversionMap);\n        for (let action of remainingActions) {\n            await convertAction(action, postStepResults, utils, external, actionConversionMap);\n        }\n\n        results.push((parameters, context) => {\n            if (!lockResolution.valueOf(parameters)) {\n                execute(postStepResults, parameters, context);\n            } else {\n                context.locked = true;\n                const step: ExecutionStep = (parameters, context) => {\n                    for (let i in parameters) {\n                        postExecution.parameters[i] = parameters[i];\n                    }\n                    if (!context.locked) {\n                        context.postActionListener.delete(postExecution);\n                        execute(postStepResults, parameters, context);    \n                    }\n                };\n                const postExecution: ExecutionWithParams = {\n                    steps: [step],\n                    parameters,\n                };\n        \n                context.postActionListener.add(postExecution);\n            }\n        });\n        return ConvertBehavior.SKIP_REMAINING_ACTIONS;\n    }\n}","import { SetAction } from \"../actions/SetAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\nimport { calculateResolution } from \"../resolutions/calculate\";\nimport { calculateString } from \"../resolutions/calculateString\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ConvertBehavior } from \"./Convertor\";\nimport { newParams, recycleParams } from \"./parameter-utils\";\n\nexport async function convertSetProperty(\n        action: SetAction,\n        results: ExecutionStep[]): Promise<ConvertBehavior|void> {\n    if (!action.set) {\n        return;\n    }\n    const { set } = action;\n    const variable = calculateString(set.variable);\n    const access = [variable, ...(set.access?.map(a => calculateResolution(a)) ?? [])];\n    const value = calculateResolution(set.value);\n\n    results.push((parameters)=> {\n        let root: any = parameters;\n        for (let i = 0; i < access.length; i++) {\n            if (!root) {\n                console.warn(\"Invalid access\");\n                return;\n            }\n            const key = access[i]?.valueOf(parameters);\n            if (Array.isArray(root)) {\n                if (typeof key === \"number\") {\n                    if (i === access.length - 1) {\n                        parameters.value = root[key];\n                        root[key] = value?.valueOf(parameters);\n                    } else {\n                        root = root[key];\n                    }\n                } else {\n                    console.warn(\"Invalid key for array: \", key);\n                }\n            } else if (typeof(root) === \"object\") {\n                if (i === access.length - 1) {\n                    parameters.value = root[key + \"\"];\n                    root[key + \"\"] = value?.valueOf(parameters);\n                } else {\n                    root = root[key + \"\"];\n                }\n            }    \n        }\n    });    \n}\n\nexport async function convertSetsProperty(\n        action: SetAction,\n        results: ExecutionStep[]): Promise<ConvertBehavior|void> {\n    if (!action.sets) {\n        return;\n    }\n    const { sets } = action;\n    const setsEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = !sets ? [] : Object.entries(sets).map(([key, value]) => [key, calculateResolution(value)]);\n\n    results.push((parameters, context)=> {\n        const paramsTemp = newParams(undefined, context);\n\n        for (const [key, value] of setsEntries) {\n            parameters.value = parameters[key];\n            paramsTemp[key] = value?.valueOf(parameters);    \n        }\n        delete parameters.value;\n        for (const [key] of setsEntries) {\n            parameters[key] = paramsTemp[key];\n        }\n        recycleParams(paramsTemp, context);\n    });    \n}\n\nexport async function convertDefaultValuesProperty(\n    action: SetAction,\n    results: ExecutionStep[]): Promise<ConvertBehavior|void> {\nif (!action.defaultValues) {\n    return;\n}\nconst { defaultValues } = action;\nconst defaultValuesEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = !defaultValues ? [] : Object.entries(defaultValues).map(([key, value]) => [key, calculateResolution(value)]);\n\nresults.push((parameters, context)=> {\n    const paramsTemp = newParams(undefined, context);\n\n    for (const [key, value] of defaultValuesEntries) {\n        parameters.value = parameters[key];\n        paramsTemp[key] = value?.valueOf(parameters);    \n    }\n    delete parameters.value;\n    for (const [key] of defaultValuesEntries) {\n        if (parameters[key] === undefined) {\n            parameters[key] = paramsTemp[key];\n        }\n    }\n    recycleParams(paramsTemp, context);\n});    \n}\n","import { HookAction } from \"../actions/HookAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { StringResolution } from \"../resolutions/StringResolution\";\nimport { calculateString } from \"../resolutions/calculateString\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\n\nexport async function convertHooksProperty<T>(\n        action: HookAction & T,\n        results: ExecutionStep[],\n        _: Utils<T & HookAction>,\n        external: Record<string, any>): Promise<ConvertBehavior|void> {\n    if (!action.hooks) {\n        return;\n    }\n    const { hooks } = action;\n\n    const hooksResolution: StringResolution[] = hooks;\n    const hooksValueOf: ValueOf<string>[] = hooksResolution.map(hook => calculateString(hook));\n\n    results.push((parameters) => {\n        for (let hook of hooksValueOf) {\n            const h = hook.valueOf(parameters);\n            const x = external[h];\n            if (x) {\n                parameters[h] = x;\n            } else {\n                console.warn(\"Does not exist\", x);\n            }\n        }\n    });\n}\n","import { LogAction } from \"../actions/LogAction\";\nimport { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { Resolution } from \"../resolutions/Resolution\";\nimport { calculateResolution } from \"../resolutions/calculate\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\n\nexport async function convertLogProperty<T>(\n        action: LogAction,\n        results: ExecutionStep[],\n        _: Utils<T>,\n        external: Record<string, any>): Promise<ConvertBehavior|void> {\n    if (action.log === undefined) {\n        return;\n    }\n    const messages: Resolution[] = Array.isArray(action.log) ? action.log : [action.log];\n    const resolutions = messages.map(m => calculateResolution(m));\n    results.push((parameters)=> external.log(...resolutions.map(r => r?.valueOf(parameters))));    \n}\n","import { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { calculateNumber } from \"../resolutions/calculateNumber\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { LogicAction } from \"../actions/LogicAction\";\nimport { Context } from \"../context/Context\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\n\nconst VARIABLE_NAMES = \"ijklmnopqrstuvwxyzabcdefgh\".split(\"\");\n\nfunction keepLooping(parameters: ExecutionParameters, context: Context, loops: ValueOf<number>[], steps: ExecutionStep[], depth: number = 0) {\n    if (depth >= loops.length) {\n        execute(steps, parameters, context);\n        return;\n    }\n    const length = loops[depth].valueOf(parameters);\n    const p = parameters;\n    const letter = VARIABLE_NAMES[depth];\n    for (let i = 0; i < length; i++) {\n        p.index = p[letter] = i;\n        keepLooping(p, context, loops, steps, depth + 1);\n    }\n}\n\nexport async function convertLoopProperty<T>(\n        action: T & LogicAction,\n        stepResults: ExecutionStep[],\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (action.loop === undefined) {\n        return;\n    }\n    if (!action.loop) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { loop, ...subAction } = action;\n    const loops = Array.isArray(loop) ? loop: [loop];\n    if (!loops.length) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const loopResolution = loops.map(loop => calculateNumber(loop, 0));\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, actionConversionMap);\n    stepResults.push((parameters, context) =>  keepLooping(parameters, context, loopResolution, subStepResults));\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\nexport async function convertWhileProperty<T>(\n        action: T & LogicAction,\n        stepResults: ExecutionStep[],\n        utils: Utils<T & LogicAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (action.whileCondition === undefined) {\n        return;\n    }\n    if (!action.whileCondition) {\n        return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n    }\n    const { whileCondition, ...subAction } = action;\n    const whileResolution = calculateBoolean(whileCondition);\n    const subStepResults: ExecutionStep[] = [];\n    await convertAction<LogicAction>(subAction, subStepResults, utils, external, actionConversionMap);\n    stepResults.push((parameters, context) =>  {\n        while(whileResolution.valueOf(parameters)) {\n            execute(subStepResults, parameters, context);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n\n","import { ConvertBehavior, Utils } from \"./Convertor\";\nimport { calculateResolution } from \"../resolutions/calculate\";\nimport { ValueOf } from \"../types/ValueOf\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { SupportedTypes } from \"../resolutions/SupportedTypes\";\nimport { ScriptAction } from \"../actions/ScriptAction\";\nimport { newParams, recycleParams } from \"./parameter-utils\";\n\nexport async function convertParametersProperty<T>(\n        action: ScriptAction,\n        results: ExecutionStep[],\n        utils: Utils<T & ScriptAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.parameters) {\n        return;\n    }\n    const { parameters, ...subAction } = action;\n\n    const paramEntries: [string, ValueOf<SupportedTypes> | undefined | null][] = Object.entries(parameters ?? {})\n        .map(([key, resolution]) => [key, calculateResolution(resolution)]);\n    \n    const subStepResults: ExecutionStep[] = [];\n    await convertAction(subAction, subStepResults, utils, external, actionConversionMap);\n\n    results.push((parameters, context) => {\n        const paramValues: ExecutionParameters = newParams(undefined, context);\n        for (let entry of paramEntries) {\n            const key: string = entry[0];\n            paramValues[key] = entry[1]?.valueOf(parameters);\n        }\n\n        execute(subStepResults, paramValues, context);\n\n        recycleParams(paramValues, context);\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ExecutionStep } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\nimport { calculateNumber } from \"../resolutions/calculateNumber\";\nimport { ActionConvertorList, convertAction } from \"./convert-action\";\nimport { RefreshAction } from \"../actions/RefreshAction\";\nimport { calculateBoolean } from \"../resolutions/calculateBoolean\";\nimport { calculateString } from \"../resolutions/calculateString\";\n\nexport async function convertRefreshProperty<T>(\n        action: T & RefreshAction,\n        stepResults: ExecutionStep[],\n        utils: Utils<T & RefreshAction>,\n        external: Record<string, any>,\n        actionConversionMap: ActionConvertorList): Promise<ConvertBehavior | void> {\n    if (!action.refresh) {\n        return;\n    }\n    const { refresh, ...subAction } = action;\n    const subStepResults: ExecutionStep[] = [];\n    const processId = calculateString(refresh.processId, \"\");\n    const stop = calculateBoolean(refresh.stop);\n    const cleanupAfterRefresh = calculateBoolean(refresh.cleanupAfterRefresh);\n    const frameRate = calculateNumber(refresh.frameRate, 60);\n    await convertAction<RefreshAction>(subAction, subStepResults, utils, external, actionConversionMap);\n\n    stepResults.push((parameters, context) => {\n        if (stop.valueOf(parameters)) {\n            utils.stopRefresh(processId.valueOf(parameters));\n        } else {\n            const cleanup = utils.refreshSteps(subStepResults, {\n                cleanupAfterRefresh: cleanupAfterRefresh.valueOf(parameters),\n                frameRate: frameRate.valueOf(parameters),\n                parameters,\n            }, processId.valueOf(parameters));\n            context.cleanupActions.push(cleanup);\n        }\n    });\n    return ConvertBehavior.SKIP_REMAINING_CONVERTORS;\n}\n","import { ScriptAction } from \"../actions/ScriptAction\";\nimport { ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { ConvertBehavior, Utils } from \"./Convertor\";\n\nexport async function convertScriptProperty<T>(\n        action: ScriptAction,\n        results: ExecutionStep[],\n        {getSteps}: Utils<T>): Promise<ConvertBehavior|void> {\n    if (!action.executeScript) {\n        return;\n    }\n    const { executeScript } = action;\n\n    const name = executeScript;\n    const steps = getSteps({ name });\n    results.push((parameters, context) => execute(steps, parameters, context));\n}\n\n","import { convertActionsProperty } from \"./actions-convertor\";\nimport { convertConditionProperty } from \"./condition-convertor\";\nimport { ActionConvertorList } from \"./convert-action\";\nimport { convertDelayProperty, convertLockProperty, convertPauseProperty } from \"./convert-pause\";\nimport { convertDefaultValuesProperty, convertSetProperty, convertSetsProperty } from \"./convert-set\";\nimport { convertHooksProperty } from \"./hooks-convertor\";\nimport { convertLogProperty } from \"./log-convertor\";\nimport { convertLoopProperty } from \"./loop-convertor\";\nimport { convertParametersProperty } from \"./parameters-convertor\";\nimport { convertRefreshProperty } from \"./refresh-convertor\";\nimport { convertScriptProperty } from \"./script-convertor\";\n\nexport function getDefaultConvertors(): ActionConvertorList {\n    return [\n        convertHooksProperty,\n        convertParametersProperty,\n        convertDefaultValuesProperty,\n        convertRefreshProperty,\n        convertLoopProperty,\n        convertConditionProperty,\n        convertDelayProperty,\n        convertPauseProperty,\n        convertLockProperty,\n        convertSetProperty,\n        convertSetsProperty,\n        convertLogProperty,\n        convertScriptProperty,\n        convertActionsProperty,\n    ];\n}\n","import { Context, createContext } from \"../context/Context\";\nimport { ActionConvertorList, convertScripts } from \"../convertor/convert-action\";\nimport { getDefaultConvertors } from \"../convertor/default-convertors\";\nimport { DEFAULT_EXTERNALS } from \"../convertor/default-externals\";\nimport { ExecutionParameters, ExecutionStep, execute } from \"../execution/ExecutionStep\";\nimport { Script, ScriptFilter, Tag, filterScripts } from \"../scripts/Script\";\n\nexport interface RefreshBehavior {\n    frameRate?: number;\n    cleanupAfterRefresh?: boolean;\n    parameters?: ExecutionParameters;\n}\n\nexport interface ScriptProcessorHelper {\n    refreshSteps(steps: ExecutionStep[], behavior?: RefreshBehavior, processId?: string): () => void;\n    stopRefresh(processId: string): void;\n}\n\nexport class ScriptProcessor<T, E = {}> {\n    private scripts: Script<T>[];\n    private scriptMap?: Map<Script<T>, ExecutionStep[]>;\n    private external: (E|{}) & typeof DEFAULT_EXTERNALS;\n    private actionConversionMap: ActionConvertorList;\n    private refreshCleanups: Record<string, () => void> = {};\n\n    constructor(scripts: Script<T>[], external = {}, actionConversionMap: ActionConvertorList = getDefaultConvertors()) {\n        this.scripts = scripts;\n        this.actionConversionMap = actionConversionMap;\n        this.external = {...DEFAULT_EXTERNALS, ...external};\n    }\n\n    clear() {\n        Object.values(this.refreshCleanups).forEach(cleanup => {\n            cleanup();\n        });\n        Object.keys(this.refreshCleanups).forEach(key => {\n            delete this.refreshCleanups[key];\n        });\n    }\n\n    private async fetchScripts(): Promise<Map<Script<T>, ExecutionStep[]>> {\n        if (!this.scriptMap) {\n            this.scriptMap = await convertScripts(this.scripts, this.external, this.actionConversionMap, {\n                refreshSteps: this.refreshSteps.bind(this),\n                stopRefresh: this.stopRefresh.bind(this),\n            });\n        }\n        return this.scriptMap!;\n    }\n\n    private createRefreshCleanup(behavior: RefreshBehavior, context: Context) {\n        const cleanupActions = context.cleanupActions;\n        return behavior.cleanupAfterRefresh && cleanupActions ? () => {\n            for (let cleanup of cleanupActions) {\n                cleanup();\n            }\n            cleanupActions.length = 0;\n        } : () => {};\n    }\n\n    async getSteps(filter: ScriptFilter) {\n        const scriptMap = await this.fetchScripts();\n        const scripts = filterScripts(this.scripts, filter);\n        const steps: ExecutionStep[] = [];\n        scripts.forEach(script => scriptMap.get(script)?.forEach(step => steps.push(step)));\n        return steps;\n    }\n\n    async runByName(name: string, parameters?: ExecutionParameters) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ name }), parameters, context);\n        return () => context.cleanupActions?.forEach(action => action());\n    }\n\n    async runByTags(tags: Tag[], parameters?: ExecutionParameters) {\n        const context: Context = createContext();\n        execute(await this.getSteps({ tags }), parameters, context);\n        return () => context.cleanupActions?.forEach(action => action());\n    }\n\n    private async refreshWithFilter(filter: ScriptFilter, behavior: RefreshBehavior = {}) {\n        return this.refreshSteps(await this.getSteps(filter), behavior);\n    }\n\n    private stopRefresh(processId: string) {\n        this.refreshCleanups[processId]?.();\n        delete this.refreshCleanups[processId];\n    }\n    \n    private refreshSteps(steps: ExecutionStep[], behavior: RefreshBehavior = {}, processId?: string) {\n        const context: Context = createContext();\n        const parameters: ExecutionParameters = { ...behavior.parameters, time: 0, frame: 0 };\n        const refreshCleanup = this.createRefreshCleanup(behavior, context);\n        const frameRate = behavior.frameRate ?? 60;\n        const frameMs = 1000 / frameRate;\n        let lastFrameTime = Number.MIN_SAFE_INTEGER;\n        let frame = 0;\n        const loop = (time: number) => {\n            if (time >= lastFrameTime + frameMs) {\n                parameters.time = time;\n                parameters.frame = frame;\n                execute(steps, parameters, context);\n                refreshCleanup();\n                frame++;\n                lastFrameTime = time;\n            }\n            animationFrameId = requestAnimationFrame(loop);\n        };\n        let animationFrameId = requestAnimationFrame(loop);\n        const cleanup = () => {\n            refreshCleanup();\n            cancelAnimationFrame(animationFrameId);\n        }\n        if (processId?.length) {\n            this.refreshCleanups[processId] = cleanup;\n        }\n\n        return cleanup;\n    }\n    \n    refreshByName(name: string, behavior: RefreshBehavior = {}) {\n        return this.refreshWithFilter({ name }, behavior);\n    }\n\n    refreshByTags(tags: string[], behavior: RefreshBehavior = {}) {\n        return this.refreshWithFilter({ tags }, behavior);\n    }\n}"],"names":["DEFAULT_EXTERNALS","log","console","setTimeout","clearTimeout","fetch","global","createContext","_temp","_ref$parameters","_ref","parameters","_ref$cleanupActions","cleanupActions","_ref$objectPool","objectPool","_ref$postActionListen","postActionListener","Set","_ref$external","external","_extends","locked","ConvertBehavior","execute","steps","context","length","params","changedParameters","push","_iterator","_createForOfIteratorHelperLoose","_step","done","step","value","forEach","listener","i","pop","filterMatchesTags","filter","tags","_filter$tags","every","tag","some","t","Array","isArray","filterScripts","scripts","namesToFilter","name","undefined","indexOf","executeAction","action","utils","actionConversionMap","results","_ConvertBehavior$SKIP","SKIP_REMAINING_ACTIONS","Promise","resolve","convertAction","then","_convertAction","e","reject","executeScript","scriptName","processorHelper","convertScripts","scriptMap","script","find","get","Map","set","getSteps","filteredScripts","apply","_temp2","_forOf","_scriptMap$get","_interrupt","scriptSteps","actions","_forTo","getRemainingActions","slice","refreshSteps","stopRefresh","convertBehavior","stepResults","convertor","SKIP_REMAINING_CONVERTORS","_exit","newParams","_context$objectPool$p","_context$objectPool","k","recycleParams","_context$objectPool2","FORMULA_SEPERATORS","hasFormula","resolution","isFormula","item","Object","values","keys","formula","_FORMULA_SEPERATORS$m","map","char","startCharacter","prefix","suffix","getInnerFormulas","substring","split","chunk","index","textSuffix","_chunk$split","IDENTIFIER_REGEX","isSimpleInnerFormula","innerFormula","test","calculateEvaluator","evaluator","defaultValue","scope","_evaluator$evaluate","evaluate","error","JSON","parse","stringify","getEvaluator","mathEvaluator","math","compile","_scope$formula","getFormulaEvaluator","Error","evaluators","_ref2","join","calculateArray","array","valueOf","calculateResolution","evalItem","calculateMap","evaluatorEntries","entries","key","fromEntries","Float32Array","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","calculateNumber","calculateString","calculateBoolean","calculateTypedArray","ArrayConstructor","compiledArray","bufferArray","BYTES_PER_ELEMENT","convertActionsProperty","actionConvertorMap","_action$actions","a","convertConditionProperty","condition","subAction","_objectWithoutPropertiesLoose","_excluded","conditionResolution","subStepResults","convertLockProperty","lock","unlock","_excluded3","unlockResolution","lockResolution","postStepResults","remainingActions","_temp6","postExecution","add","_temp5","convertPauseProperty","pause","_excluded2","pauseResolution","_temp4","has","_temp3","convertDelayProperty","delay","delayAmount","performPostSteps","timeout","convertDefaultValuesProperty","defaultValues","defaultValuesEntries","paramsTemp","_iterator3","_step3","_step3$value","_iterator4","_step4","_step4$value","convertSetsProperty","sets","setsEntries","_step$value","_iterator2","_step2","_step2$value","convertSetProperty","variable","access","concat","_set$access$map","_set$access","root","_access$i","warn","convertHooksProperty","_","hooks","hooksResolution","hooksValueOf","hook","h","x","convertLogProperty","messages","resolutions","m","r","convertLoopProperty","loop","loops","loopResolution","keepLooping","VARIABLE_NAMES","depth","p","letter","convertParametersProperty","paramEntries","paramValues","_entry$","entry","convertRefreshProperty","refresh","processId","stop","cleanupAfterRefresh","frameRate","cleanup","convertScriptProperty","getDefaultConvertors","ScriptProcessor","_proto","prototype","clear","refreshCleanups","_this","fetchScripts","_this2","bind","_convertScripts","createRefreshCleanup","behavior","_this3","runByName","_this4","_this4$getSteps","_context$cleanupActio","runByTags","_this5","_this5$getSteps","_context$cleanupActio2","refreshWithFilter","_refreshSteps","_this6","_this6$getSteps","call","_this$refreshCleanups","_this$refreshCleanups2","time","frame","refreshCleanup","_behavior$frameRate","frameMs","lastFrameTime","Number","MIN_SAFE_INTEGER","animationFrameId","requestAnimationFrame","cancelAnimationFrame","refreshByName","refreshByTags"],"mappings":"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"}